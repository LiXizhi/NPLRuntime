#include "Python3ParserBase.h"

// Generated from Python3Parser.g4 by ANTLR 4.13.1


#include "Python3ParserListener.h"
#include "Python3ParserVisitor.h"

#include "Python3Parser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct Python3ParserStaticData final {
  Python3ParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  Python3ParserStaticData(const Python3ParserStaticData&) = delete;
  Python3ParserStaticData(Python3ParserStaticData&&) = delete;
  Python3ParserStaticData& operator=(const Python3ParserStaticData&) = delete;
  Python3ParserStaticData& operator=(Python3ParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag python3parserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
Python3ParserStaticData *python3parserParserStaticData = nullptr;

void python3parserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (python3parserParserStaticData != nullptr) {
    return;
  }
#else
  assert(python3parserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<Python3ParserStaticData>(
    std::vector<std::string>{
      "single_input", "file_input", "eval_input", "decorator", "decorators", 
      "decorated", "async_funcdef", "funcdef", "parameters", "typedargslist", 
      "tfpdef", "varargslist", "vfpdef", "stmt", "simple_stmts", "simple_stmt", 
      "expr_stmt", "annassign", "testlist_star_expr", "augassign", "del_stmt", 
      "pass_stmt", "flow_stmt", "break_stmt", "continue_stmt", "return_stmt", 
      "yield_stmt", "raise_stmt", "import_stmt", "import_name", "import_from", 
      "import_as_name", "dotted_as_name", "import_as_names", "dotted_as_names", 
      "dotted_name", "global_stmt", "nonlocal_stmt", "assert_stmt", "compound_stmt", 
      "async_stmt", "if_stmt", "while_stmt", "for_stmt", "try_stmt", "with_stmt", 
      "with_item", "except_clause", "block", "match_stmt", "subject_expr", 
      "star_named_expressions", "star_named_expression", "case_block", "guard", 
      "patterns", "pattern", "as_pattern", "or_pattern", "closed_pattern", 
      "literal_pattern", "literal_expr", "complex_number", "signed_number", 
      "signed_real_number", "real_number", "imaginary_number", "capture_pattern", 
      "pattern_capture_target", "wildcard_pattern", "value_pattern", "attr", 
      "name_or_attr", "group_pattern", "sequence_pattern", "open_sequence_pattern", 
      "maybe_sequence_pattern", "maybe_star_pattern", "star_pattern", "mapping_pattern", 
      "items_pattern", "key_value_pattern", "double_star_pattern", "class_pattern", 
      "positional_patterns", "keyword_patterns", "keyword_pattern", "test", 
      "test_nocond", "lambdef", "lambdef_nocond", "or_test", "and_test", 
      "not_test", "comparison", "comp_op", "star_expr", "expr", "atom_expr", 
      "atom", "name", "testlist_comp", "trailer", "subscriptlist", "subscript_", 
      "sliceop", "exprlist", "testlist", "dictorsetmaker", "classdef", "arglist", 
      "argument", "comp_iter", "comp_for", "comp_if", "encoding_decl", "yield_expr", 
      "yield_arg", "strings"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "'and'", "'as'", "'assert'", "'async'", "'await'", 
      "'break'", "'case'", "'class'", "'continue'", "'def'", "'del'", "'elif'", 
      "'else'", "'except'", "'False'", "'finally'", "'for'", "'from'", "'global'", 
      "'if'", "'import'", "'in'", "'is'", "'lambda'", "'match'", "'None'", 
      "'nonlocal'", "'not'", "'or'", "'pass'", "'raise'", "'return'", "'True'", 
      "'try'", "'_'", "'while'", "'with'", "'yield'", "", "", "", "", "", 
      "", "", "", "", "", "'.'", "'...'", "'*'", "'('", "')'", "','", "':'", 
      "';'", "'**'", "'='", "'['", "']'", "'|'", "'^'", "'&'", "'<<'", "'>>'", 
      "'+'", "'-'", "'/'", "'%'", "'//'", "'~'", "'{'", "'}'", "'<'", "'>'", 
      "'=='", "'>='", "'<='", "'<>'", "'!='", "'@'", "'->'", "'+='", "'-='", 
      "'*='", "'@='", "'/='", "'%='", "'&='", "'|='", "'^='", "'<<='", "'>>='", 
      "'**='", "'//='"
    },
    std::vector<std::string>{
      "", "INDENT", "DEDENT", "STRING", "NUMBER", "INTEGER", "AND", "AS", 
      "ASSERT", "ASYNC", "AWAIT", "BREAK", "CASE", "CLASS", "CONTINUE", 
      "DEF", "DEL", "ELIF", "ELSE", "EXCEPT", "FALSE", "FINALLY", "FOR", 
      "FROM", "GLOBAL", "IF", "IMPORT", "IN", "IS", "LAMBDA", "MATCH", "NONE", 
      "NONLOCAL", "NOT", "OR", "PASS", "RAISE", "RETURN", "TRUE", "TRY", 
      "UNDERSCORE", "WHILE", "WITH", "YIELD", "NEWLINE", "NAME", "STRING_LITERAL", 
      "BYTES_LITERAL", "DECIMAL_INTEGER", "OCT_INTEGER", "HEX_INTEGER", 
      "BIN_INTEGER", "FLOAT_NUMBER", "IMAG_NUMBER", "DOT", "ELLIPSIS", "STAR", 
      "OPEN_PAREN", "CLOSE_PAREN", "COMMA", "COLON", "SEMI_COLON", "POWER", 
      "ASSIGN", "OPEN_BRACK", "CLOSE_BRACK", "OR_OP", "XOR", "AND_OP", "LEFT_SHIFT", 
      "RIGHT_SHIFT", "ADD", "MINUS", "DIV", "MOD", "IDIV", "NOT_OP", "OPEN_BRACE", 
      "CLOSE_BRACE", "LESS_THAN", "GREATER_THAN", "EQUALS", "GT_EQ", "LT_EQ", 
      "NOT_EQ_1", "NOT_EQ_2", "AT", "ARROW", "ADD_ASSIGN", "SUB_ASSIGN", 
      "MULT_ASSIGN", "AT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", 
      "OR_ASSIGN", "XOR_ASSIGN", "LEFT_SHIFT_ASSIGN", "RIGHT_SHIFT_ASSIGN", 
      "POWER_ASSIGN", "IDIV_ASSIGN", "SKIP_", "UNKNOWN_CHAR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,102,1435,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,1,0,1,0,1,0,1,0,1,0,3,0,244,8,0,1,1,1,1,
  	5,1,248,8,1,10,1,12,1,251,9,1,1,1,1,1,1,2,1,2,5,2,257,8,2,10,2,12,2,260,
  	9,2,1,2,1,2,1,3,1,3,1,3,1,3,3,3,268,8,3,1,3,3,3,271,8,3,1,3,1,3,1,4,4,
  	4,276,8,4,11,4,12,4,277,1,5,1,5,1,5,1,5,3,5,284,8,5,1,6,1,6,1,6,1,7,1,
  	7,1,7,1,7,1,7,3,7,294,8,7,1,7,1,7,1,7,1,8,1,8,3,8,301,8,8,1,8,1,8,1,9,
  	1,9,1,9,3,9,308,8,9,1,9,1,9,1,9,1,9,3,9,314,8,9,5,9,316,8,9,10,9,12,9,
  	319,9,9,1,9,1,9,1,9,3,9,324,8,9,1,9,1,9,1,9,1,9,3,9,330,8,9,5,9,332,8,
  	9,10,9,12,9,335,9,9,1,9,1,9,1,9,1,9,3,9,341,8,9,3,9,343,8,9,3,9,345,8,
  	9,1,9,1,9,1,9,3,9,350,8,9,3,9,352,8,9,3,9,354,8,9,1,9,1,9,3,9,358,8,9,
  	1,9,1,9,1,9,1,9,3,9,364,8,9,5,9,366,8,9,10,9,12,9,369,9,9,1,9,1,9,1,9,
  	1,9,3,9,375,8,9,3,9,377,8,9,3,9,379,8,9,1,9,1,9,1,9,3,9,384,8,9,3,9,386,
  	8,9,1,10,1,10,1,10,3,10,391,8,10,1,11,1,11,1,11,3,11,396,8,11,1,11,1,
  	11,1,11,1,11,3,11,402,8,11,5,11,404,8,11,10,11,12,11,407,9,11,1,11,1,
  	11,1,11,3,11,412,8,11,1,11,1,11,1,11,1,11,3,11,418,8,11,5,11,420,8,11,
  	10,11,12,11,423,9,11,1,11,1,11,1,11,1,11,3,11,429,8,11,3,11,431,8,11,
  	3,11,433,8,11,1,11,1,11,1,11,3,11,438,8,11,3,11,440,8,11,3,11,442,8,11,
  	1,11,1,11,3,11,446,8,11,1,11,1,11,1,11,1,11,3,11,452,8,11,5,11,454,8,
  	11,10,11,12,11,457,9,11,1,11,1,11,1,11,1,11,3,11,463,8,11,3,11,465,8,
  	11,3,11,467,8,11,1,11,1,11,1,11,3,11,472,8,11,3,11,474,8,11,1,12,1,12,
  	1,13,1,13,3,13,480,8,13,1,14,1,14,1,14,5,14,485,8,14,10,14,12,14,488,
  	9,14,1,14,3,14,491,8,14,1,14,1,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	1,15,3,15,503,8,15,1,16,1,16,1,16,1,16,1,16,3,16,510,8,16,1,16,1,16,1,
  	16,3,16,515,8,16,5,16,517,8,16,10,16,12,16,520,9,16,3,16,522,8,16,1,17,
  	1,17,1,17,1,17,3,17,528,8,17,1,18,1,18,3,18,532,8,18,1,18,1,18,1,18,3,
  	18,537,8,18,5,18,539,8,18,10,18,12,18,542,9,18,1,18,3,18,545,8,18,1,19,
  	1,19,1,20,1,20,1,20,1,21,1,21,1,22,1,22,1,22,1,22,1,22,3,22,559,8,22,
  	1,23,1,23,1,24,1,24,1,25,1,25,3,25,567,8,25,1,26,1,26,1,27,1,27,1,27,
  	1,27,3,27,575,8,27,3,27,577,8,27,1,28,1,28,3,28,581,8,28,1,29,1,29,1,
  	29,1,30,1,30,5,30,588,8,30,10,30,12,30,591,9,30,1,30,1,30,4,30,595,8,
  	30,11,30,12,30,596,3,30,599,8,30,1,30,1,30,1,30,1,30,1,30,1,30,1,30,3,
  	30,608,8,30,1,31,1,31,1,31,3,31,613,8,31,1,32,1,32,1,32,3,32,618,8,32,
  	1,33,1,33,1,33,5,33,623,8,33,10,33,12,33,626,9,33,1,33,3,33,629,8,33,
  	1,34,1,34,1,34,5,34,634,8,34,10,34,12,34,637,9,34,1,35,1,35,1,35,5,35,
  	642,8,35,10,35,12,35,645,9,35,1,36,1,36,1,36,1,36,5,36,651,8,36,10,36,
  	12,36,654,9,36,1,37,1,37,1,37,1,37,5,37,660,8,37,10,37,12,37,663,9,37,
  	1,38,1,38,1,38,1,38,3,38,669,8,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,
  	1,39,1,39,1,39,3,39,681,8,39,1,40,1,40,1,40,1,40,3,40,687,8,40,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,5,41,698,8,41,10,41,12,41,701,9,
  	41,1,41,1,41,1,41,3,41,706,8,41,1,42,1,42,1,42,1,42,1,42,1,42,1,42,3,
  	42,715,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,726,8,43,
  	1,44,1,44,1,44,1,44,1,44,1,44,1,44,4,44,735,8,44,11,44,12,44,736,1,44,
  	1,44,1,44,3,44,742,8,44,1,44,1,44,1,44,3,44,747,8,44,1,44,1,44,1,44,3,
  	44,752,8,44,1,45,1,45,1,45,1,45,5,45,758,8,45,10,45,12,45,761,9,45,1,
  	45,1,45,1,45,1,46,1,46,1,46,3,46,769,8,46,1,47,1,47,1,47,1,47,3,47,775,
  	8,47,3,47,777,8,47,1,48,1,48,1,48,1,48,4,48,783,8,48,11,48,12,48,784,
  	1,48,1,48,3,48,789,8,48,1,49,1,49,1,49,1,49,1,49,1,49,4,49,797,8,49,11,
  	49,12,49,798,1,49,1,49,1,50,1,50,1,50,3,50,806,8,50,1,50,3,50,809,8,50,
  	1,51,1,51,4,51,813,8,51,11,51,12,51,814,1,51,3,51,818,8,51,1,52,1,52,
  	1,52,3,52,823,8,52,1,53,1,53,1,53,3,53,828,8,53,1,53,1,53,1,53,1,54,1,
  	54,1,54,1,55,1,55,3,55,838,8,55,1,56,1,56,3,56,842,8,56,1,57,1,57,1,57,
  	1,57,1,58,1,58,1,58,5,58,851,8,58,10,58,12,58,854,9,58,1,59,1,59,1,59,
  	1,59,1,59,1,59,1,59,1,59,3,59,864,8,59,1,60,1,60,1,60,1,60,1,60,1,60,
  	1,60,1,60,3,60,874,8,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,1,61,3,61,
  	884,8,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,894,8,62,1,63,1,
  	63,1,63,3,63,899,8,63,1,64,1,64,1,64,3,64,904,8,64,1,65,1,65,1,66,1,66,
  	1,67,1,67,1,68,1,68,1,68,1,69,1,69,1,70,1,70,1,70,1,71,1,71,1,71,4,71,
  	923,8,71,11,71,12,71,924,1,72,1,72,3,72,929,8,72,1,73,1,73,1,73,1,73,
  	1,74,1,74,3,74,937,8,74,1,74,1,74,1,74,3,74,942,8,74,1,74,3,74,945,8,
  	74,1,75,1,75,1,75,3,75,950,8,75,1,76,1,76,1,76,5,76,955,8,76,10,76,12,
  	76,958,9,76,1,76,3,76,961,8,76,1,77,1,77,3,77,965,8,77,1,78,1,78,1,78,
  	1,78,3,78,971,8,78,1,79,1,79,1,79,1,79,1,79,3,79,978,8,79,1,79,1,79,1,
  	79,1,79,1,79,1,79,1,79,3,79,987,8,79,1,79,1,79,1,79,1,79,1,79,3,79,994,
  	8,79,1,79,1,79,3,79,998,8,79,1,80,1,80,1,80,5,80,1003,8,80,10,80,12,80,
  	1006,9,80,1,81,1,81,3,81,1010,8,81,1,81,1,81,1,81,1,82,1,82,1,82,1,83,
  	1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,1026,8,83,1,83,1,83,1,83,1,83,
  	1,83,1,83,3,83,1034,8,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,
  	1044,8,83,1,83,1,83,3,83,1048,8,83,1,84,1,84,1,84,5,84,1053,8,84,10,84,
  	12,84,1056,9,84,1,85,1,85,1,85,5,85,1061,8,85,10,85,12,85,1064,9,85,1,
  	86,1,86,1,86,1,86,1,87,1,87,1,87,1,87,1,87,1,87,3,87,1076,8,87,1,87,3,
  	87,1079,8,87,1,88,1,88,3,88,1083,8,88,1,89,1,89,3,89,1087,8,89,1,89,1,
  	89,1,89,1,90,1,90,3,90,1094,8,90,1,90,1,90,1,90,1,91,1,91,1,91,5,91,1102,
  	8,91,10,91,12,91,1105,9,91,1,92,1,92,1,92,5,92,1110,8,92,10,92,12,92,
  	1113,9,92,1,93,1,93,1,93,3,93,1118,8,93,1,94,1,94,1,94,1,94,5,94,1124,
  	8,94,10,94,12,94,1127,9,94,1,95,1,95,1,95,1,95,1,95,1,95,1,95,1,95,1,
  	95,1,95,1,95,1,95,1,95,3,95,1142,8,95,1,96,1,96,1,96,1,97,1,97,1,97,4,
  	97,1150,8,97,11,97,12,97,1151,1,97,3,97,1155,8,97,1,97,1,97,1,97,1,97,
  	1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,
  	1,97,1,97,1,97,5,97,1178,8,97,10,97,12,97,1181,9,97,1,98,3,98,1184,8,
  	98,1,98,1,98,5,98,1188,8,98,10,98,12,98,1191,9,98,1,99,1,99,1,99,3,99,
  	1196,8,99,1,99,1,99,1,99,3,99,1201,8,99,1,99,1,99,1,99,3,99,1206,8,99,
  	1,99,1,99,1,99,1,99,4,99,1212,8,99,11,99,12,99,1213,1,99,1,99,1,99,1,
  	99,3,99,1220,8,99,1,100,1,100,1,101,1,101,3,101,1226,8,101,1,101,1,101,
  	1,101,1,101,3,101,1232,8,101,5,101,1234,8,101,10,101,12,101,1237,9,101,
  	1,101,3,101,1240,8,101,3,101,1242,8,101,1,102,1,102,3,102,1246,8,102,
  	1,102,1,102,1,102,1,102,1,102,1,102,1,102,3,102,1255,8,102,1,103,1,103,
  	1,103,5,103,1260,8,103,10,103,12,103,1263,9,103,1,103,3,103,1266,8,103,
  	1,104,1,104,3,104,1270,8,104,1,104,1,104,3,104,1274,8,104,1,104,3,104,
  	1277,8,104,3,104,1279,8,104,1,105,1,105,3,105,1283,8,105,1,106,1,106,
  	3,106,1287,8,106,1,106,1,106,1,106,3,106,1292,8,106,5,106,1294,8,106,
  	10,106,12,106,1297,9,106,1,106,3,106,1300,8,106,1,107,1,107,1,107,5,107,
  	1305,8,107,10,107,12,107,1308,9,107,1,107,3,107,1311,8,107,1,108,1,108,
  	1,108,1,108,1,108,1,108,3,108,1319,8,108,1,108,1,108,1,108,1,108,1,108,
  	1,108,1,108,1,108,3,108,1329,8,108,5,108,1331,8,108,10,108,12,108,1334,
  	9,108,1,108,3,108,1337,8,108,3,108,1339,8,108,1,108,1,108,3,108,1343,
  	8,108,1,108,1,108,1,108,1,108,3,108,1349,8,108,5,108,1351,8,108,10,108,
  	12,108,1354,9,108,1,108,3,108,1357,8,108,3,108,1359,8,108,3,108,1361,
  	8,108,1,109,1,109,1,109,1,109,3,109,1367,8,109,1,109,3,109,1370,8,109,
  	1,109,1,109,1,109,1,110,1,110,1,110,5,110,1378,8,110,10,110,12,110,1381,
  	9,110,1,110,3,110,1384,8,110,1,111,1,111,3,111,1388,8,111,1,111,1,111,
  	1,111,1,111,1,111,1,111,1,111,1,111,3,111,1398,8,111,1,112,1,112,3,112,
  	1402,8,112,1,113,3,113,1405,8,113,1,113,1,113,1,113,1,113,1,113,3,113,
  	1412,8,113,1,114,1,114,1,114,3,114,1417,8,114,1,115,1,115,1,116,1,116,
  	3,116,1423,8,116,1,117,1,117,1,117,3,117,1428,8,117,1,118,4,118,1431,
  	8,118,11,118,12,118,1432,1,118,0,1,194,119,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,226,228,230,232,234,236,0,7,1,0,88,100,1,0,54,55,2,0,71,72,
  	76,76,3,0,56,56,73,75,86,86,1,0,71,72,1,0,69,70,3,0,30,30,40,40,45,45,
  	1586,0,243,1,0,0,0,2,249,1,0,0,0,4,254,1,0,0,0,6,263,1,0,0,0,8,275,1,
  	0,0,0,10,279,1,0,0,0,12,285,1,0,0,0,14,288,1,0,0,0,16,298,1,0,0,0,18,
  	385,1,0,0,0,20,387,1,0,0,0,22,473,1,0,0,0,24,475,1,0,0,0,26,479,1,0,0,
  	0,28,481,1,0,0,0,30,502,1,0,0,0,32,504,1,0,0,0,34,523,1,0,0,0,36,531,
  	1,0,0,0,38,546,1,0,0,0,40,548,1,0,0,0,42,551,1,0,0,0,44,558,1,0,0,0,46,
  	560,1,0,0,0,48,562,1,0,0,0,50,564,1,0,0,0,52,568,1,0,0,0,54,570,1,0,0,
  	0,56,580,1,0,0,0,58,582,1,0,0,0,60,585,1,0,0,0,62,609,1,0,0,0,64,614,
  	1,0,0,0,66,619,1,0,0,0,68,630,1,0,0,0,70,638,1,0,0,0,72,646,1,0,0,0,74,
  	655,1,0,0,0,76,664,1,0,0,0,78,680,1,0,0,0,80,682,1,0,0,0,82,688,1,0,0,
  	0,84,707,1,0,0,0,86,716,1,0,0,0,88,727,1,0,0,0,90,753,1,0,0,0,92,765,
  	1,0,0,0,94,770,1,0,0,0,96,788,1,0,0,0,98,790,1,0,0,0,100,808,1,0,0,0,
  	102,810,1,0,0,0,104,822,1,0,0,0,106,824,1,0,0,0,108,832,1,0,0,0,110,837,
  	1,0,0,0,112,841,1,0,0,0,114,843,1,0,0,0,116,847,1,0,0,0,118,863,1,0,0,
  	0,120,873,1,0,0,0,122,883,1,0,0,0,124,893,1,0,0,0,126,898,1,0,0,0,128,
  	903,1,0,0,0,130,905,1,0,0,0,132,907,1,0,0,0,134,909,1,0,0,0,136,911,1,
  	0,0,0,138,914,1,0,0,0,140,916,1,0,0,0,142,919,1,0,0,0,144,928,1,0,0,0,
  	146,930,1,0,0,0,148,944,1,0,0,0,150,946,1,0,0,0,152,951,1,0,0,0,154,964,
  	1,0,0,0,156,970,1,0,0,0,158,997,1,0,0,0,160,999,1,0,0,0,162,1009,1,0,
  	0,0,164,1014,1,0,0,0,166,1047,1,0,0,0,168,1049,1,0,0,0,170,1057,1,0,0,
  	0,172,1065,1,0,0,0,174,1078,1,0,0,0,176,1082,1,0,0,0,178,1084,1,0,0,0,
  	180,1091,1,0,0,0,182,1098,1,0,0,0,184,1106,1,0,0,0,186,1117,1,0,0,0,188,
  	1119,1,0,0,0,190,1141,1,0,0,0,192,1143,1,0,0,0,194,1154,1,0,0,0,196,1183,
  	1,0,0,0,198,1219,1,0,0,0,200,1221,1,0,0,0,202,1225,1,0,0,0,204,1254,1,
  	0,0,0,206,1256,1,0,0,0,208,1278,1,0,0,0,210,1280,1,0,0,0,212,1286,1,0,
  	0,0,214,1301,1,0,0,0,216,1360,1,0,0,0,218,1362,1,0,0,0,220,1374,1,0,0,
  	0,222,1397,1,0,0,0,224,1401,1,0,0,0,226,1404,1,0,0,0,228,1413,1,0,0,0,
  	230,1418,1,0,0,0,232,1420,1,0,0,0,234,1427,1,0,0,0,236,1430,1,0,0,0,238,
  	244,5,44,0,0,239,244,3,28,14,0,240,241,3,78,39,0,241,242,5,44,0,0,242,
  	244,1,0,0,0,243,238,1,0,0,0,243,239,1,0,0,0,243,240,1,0,0,0,244,1,1,0,
  	0,0,245,248,5,44,0,0,246,248,3,26,13,0,247,245,1,0,0,0,247,246,1,0,0,
  	0,248,251,1,0,0,0,249,247,1,0,0,0,249,250,1,0,0,0,250,252,1,0,0,0,251,
  	249,1,0,0,0,252,253,5,0,0,1,253,3,1,0,0,0,254,258,3,214,107,0,255,257,
  	5,44,0,0,256,255,1,0,0,0,257,260,1,0,0,0,258,256,1,0,0,0,258,259,1,0,
  	0,0,259,261,1,0,0,0,260,258,1,0,0,0,261,262,5,0,0,1,262,5,1,0,0,0,263,
  	264,5,86,0,0,264,270,3,70,35,0,265,267,5,57,0,0,266,268,3,220,110,0,267,
  	266,1,0,0,0,267,268,1,0,0,0,268,269,1,0,0,0,269,271,5,58,0,0,270,265,
  	1,0,0,0,270,271,1,0,0,0,271,272,1,0,0,0,272,273,5,44,0,0,273,7,1,0,0,
  	0,274,276,3,6,3,0,275,274,1,0,0,0,276,277,1,0,0,0,277,275,1,0,0,0,277,
  	278,1,0,0,0,278,9,1,0,0,0,279,283,3,8,4,0,280,284,3,218,109,0,281,284,
  	3,14,7,0,282,284,3,12,6,0,283,280,1,0,0,0,283,281,1,0,0,0,283,282,1,0,
  	0,0,284,11,1,0,0,0,285,286,5,9,0,0,286,287,3,14,7,0,287,13,1,0,0,0,288,
  	289,5,15,0,0,289,290,3,200,100,0,290,293,3,16,8,0,291,292,5,87,0,0,292,
  	294,3,174,87,0,293,291,1,0,0,0,293,294,1,0,0,0,294,295,1,0,0,0,295,296,
  	5,60,0,0,296,297,3,96,48,0,297,15,1,0,0,0,298,300,5,57,0,0,299,301,3,
  	18,9,0,300,299,1,0,0,0,300,301,1,0,0,0,301,302,1,0,0,0,302,303,5,58,0,
  	0,303,17,1,0,0,0,304,307,3,20,10,0,305,306,5,63,0,0,306,308,3,174,87,
  	0,307,305,1,0,0,0,307,308,1,0,0,0,308,317,1,0,0,0,309,310,5,59,0,0,310,
  	313,3,20,10,0,311,312,5,63,0,0,312,314,3,174,87,0,313,311,1,0,0,0,313,
  	314,1,0,0,0,314,316,1,0,0,0,315,309,1,0,0,0,316,319,1,0,0,0,317,315,1,
  	0,0,0,317,318,1,0,0,0,318,353,1,0,0,0,319,317,1,0,0,0,320,351,5,59,0,
  	0,321,323,5,56,0,0,322,324,3,20,10,0,323,322,1,0,0,0,323,324,1,0,0,0,
  	324,333,1,0,0,0,325,326,5,59,0,0,326,329,3,20,10,0,327,328,5,63,0,0,328,
  	330,3,174,87,0,329,327,1,0,0,0,329,330,1,0,0,0,330,332,1,0,0,0,331,325,
  	1,0,0,0,332,335,1,0,0,0,333,331,1,0,0,0,333,334,1,0,0,0,334,344,1,0,0,
  	0,335,333,1,0,0,0,336,342,5,59,0,0,337,338,5,62,0,0,338,340,3,20,10,0,
  	339,341,5,59,0,0,340,339,1,0,0,0,340,341,1,0,0,0,341,343,1,0,0,0,342,
  	337,1,0,0,0,342,343,1,0,0,0,343,345,1,0,0,0,344,336,1,0,0,0,344,345,1,
  	0,0,0,345,352,1,0,0,0,346,347,5,62,0,0,347,349,3,20,10,0,348,350,5,59,
  	0,0,349,348,1,0,0,0,349,350,1,0,0,0,350,352,1,0,0,0,351,321,1,0,0,0,351,
  	346,1,0,0,0,351,352,1,0,0,0,352,354,1,0,0,0,353,320,1,0,0,0,353,354,1,
  	0,0,0,354,386,1,0,0,0,355,357,5,56,0,0,356,358,3,20,10,0,357,356,1,0,
  	0,0,357,358,1,0,0,0,358,367,1,0,0,0,359,360,5,59,0,0,360,363,3,20,10,
  	0,361,362,5,63,0,0,362,364,3,174,87,0,363,361,1,0,0,0,363,364,1,0,0,0,
  	364,366,1,0,0,0,365,359,1,0,0,0,366,369,1,0,0,0,367,365,1,0,0,0,367,368,
  	1,0,0,0,368,378,1,0,0,0,369,367,1,0,0,0,370,376,5,59,0,0,371,372,5,62,
  	0,0,372,374,3,20,10,0,373,375,5,59,0,0,374,373,1,0,0,0,374,375,1,0,0,
  	0,375,377,1,0,0,0,376,371,1,0,0,0,376,377,1,0,0,0,377,379,1,0,0,0,378,
  	370,1,0,0,0,378,379,1,0,0,0,379,386,1,0,0,0,380,381,5,62,0,0,381,383,
  	3,20,10,0,382,384,5,59,0,0,383,382,1,0,0,0,383,384,1,0,0,0,384,386,1,
  	0,0,0,385,304,1,0,0,0,385,355,1,0,0,0,385,380,1,0,0,0,386,19,1,0,0,0,
  	387,390,3,200,100,0,388,389,5,60,0,0,389,391,3,174,87,0,390,388,1,0,0,
  	0,390,391,1,0,0,0,391,21,1,0,0,0,392,395,3,24,12,0,393,394,5,63,0,0,394,
  	396,3,174,87,0,395,393,1,0,0,0,395,396,1,0,0,0,396,405,1,0,0,0,397,398,
  	5,59,0,0,398,401,3,24,12,0,399,400,5,63,0,0,400,402,3,174,87,0,401,399,
  	1,0,0,0,401,402,1,0,0,0,402,404,1,0,0,0,403,397,1,0,0,0,404,407,1,0,0,
  	0,405,403,1,0,0,0,405,406,1,0,0,0,406,441,1,0,0,0,407,405,1,0,0,0,408,
  	439,5,59,0,0,409,411,5,56,0,0,410,412,3,24,12,0,411,410,1,0,0,0,411,412,
  	1,0,0,0,412,421,1,0,0,0,413,414,5,59,0,0,414,417,3,24,12,0,415,416,5,
  	63,0,0,416,418,3,174,87,0,417,415,1,0,0,0,417,418,1,0,0,0,418,420,1,0,
  	0,0,419,413,1,0,0,0,420,423,1,0,0,0,421,419,1,0,0,0,421,422,1,0,0,0,422,
  	432,1,0,0,0,423,421,1,0,0,0,424,430,5,59,0,0,425,426,5,62,0,0,426,428,
  	3,24,12,0,427,429,5,59,0,0,428,427,1,0,0,0,428,429,1,0,0,0,429,431,1,
  	0,0,0,430,425,1,0,0,0,430,431,1,0,0,0,431,433,1,0,0,0,432,424,1,0,0,0,
  	432,433,1,0,0,0,433,440,1,0,0,0,434,435,5,62,0,0,435,437,3,24,12,0,436,
  	438,5,59,0,0,437,436,1,0,0,0,437,438,1,0,0,0,438,440,1,0,0,0,439,409,
  	1,0,0,0,439,434,1,0,0,0,439,440,1,0,0,0,440,442,1,0,0,0,441,408,1,0,0,
  	0,441,442,1,0,0,0,442,474,1,0,0,0,443,445,5,56,0,0,444,446,3,24,12,0,
  	445,444,1,0,0,0,445,446,1,0,0,0,446,455,1,0,0,0,447,448,5,59,0,0,448,
  	451,3,24,12,0,449,450,5,63,0,0,450,452,3,174,87,0,451,449,1,0,0,0,451,
  	452,1,0,0,0,452,454,1,0,0,0,453,447,1,0,0,0,454,457,1,0,0,0,455,453,1,
  	0,0,0,455,456,1,0,0,0,456,466,1,0,0,0,457,455,1,0,0,0,458,464,5,59,0,
  	0,459,460,5,62,0,0,460,462,3,24,12,0,461,463,5,59,0,0,462,461,1,0,0,0,
  	462,463,1,0,0,0,463,465,1,0,0,0,464,459,1,0,0,0,464,465,1,0,0,0,465,467,
  	1,0,0,0,466,458,1,0,0,0,466,467,1,0,0,0,467,474,1,0,0,0,468,469,5,62,
  	0,0,469,471,3,24,12,0,470,472,5,59,0,0,471,470,1,0,0,0,471,472,1,0,0,
  	0,472,474,1,0,0,0,473,392,1,0,0,0,473,443,1,0,0,0,473,468,1,0,0,0,474,
  	23,1,0,0,0,475,476,3,200,100,0,476,25,1,0,0,0,477,480,3,28,14,0,478,480,
  	3,78,39,0,479,477,1,0,0,0,479,478,1,0,0,0,480,27,1,0,0,0,481,486,3,30,
  	15,0,482,483,5,61,0,0,483,485,3,30,15,0,484,482,1,0,0,0,485,488,1,0,0,
  	0,486,484,1,0,0,0,486,487,1,0,0,0,487,490,1,0,0,0,488,486,1,0,0,0,489,
  	491,5,61,0,0,490,489,1,0,0,0,490,491,1,0,0,0,491,492,1,0,0,0,492,493,
  	5,44,0,0,493,29,1,0,0,0,494,503,3,32,16,0,495,503,3,40,20,0,496,503,3,
  	42,21,0,497,503,3,44,22,0,498,503,3,56,28,0,499,503,3,72,36,0,500,503,
  	3,74,37,0,501,503,3,76,38,0,502,494,1,0,0,0,502,495,1,0,0,0,502,496,1,
  	0,0,0,502,497,1,0,0,0,502,498,1,0,0,0,502,499,1,0,0,0,502,500,1,0,0,0,
  	502,501,1,0,0,0,503,31,1,0,0,0,504,521,3,36,18,0,505,522,3,34,17,0,506,
  	509,3,38,19,0,507,510,3,232,116,0,508,510,3,214,107,0,509,507,1,0,0,0,
  	509,508,1,0,0,0,510,522,1,0,0,0,511,514,5,63,0,0,512,515,3,232,116,0,
  	513,515,3,36,18,0,514,512,1,0,0,0,514,513,1,0,0,0,515,517,1,0,0,0,516,
  	511,1,0,0,0,517,520,1,0,0,0,518,516,1,0,0,0,518,519,1,0,0,0,519,522,1,
  	0,0,0,520,518,1,0,0,0,521,505,1,0,0,0,521,506,1,0,0,0,521,518,1,0,0,0,
  	522,33,1,0,0,0,523,524,5,60,0,0,524,527,3,174,87,0,525,526,5,63,0,0,526,
  	528,3,174,87,0,527,525,1,0,0,0,527,528,1,0,0,0,528,35,1,0,0,0,529,532,
  	3,174,87,0,530,532,3,192,96,0,531,529,1,0,0,0,531,530,1,0,0,0,532,540,
  	1,0,0,0,533,536,5,59,0,0,534,537,3,174,87,0,535,537,3,192,96,0,536,534,
  	1,0,0,0,536,535,1,0,0,0,537,539,1,0,0,0,538,533,1,0,0,0,539,542,1,0,0,
  	0,540,538,1,0,0,0,540,541,1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,0,543,
  	545,5,59,0,0,544,543,1,0,0,0,544,545,1,0,0,0,545,37,1,0,0,0,546,547,7,
  	0,0,0,547,39,1,0,0,0,548,549,5,16,0,0,549,550,3,212,106,0,550,41,1,0,
  	0,0,551,552,5,35,0,0,552,43,1,0,0,0,553,559,3,46,23,0,554,559,3,48,24,
  	0,555,559,3,50,25,0,556,559,3,54,27,0,557,559,3,52,26,0,558,553,1,0,0,
  	0,558,554,1,0,0,0,558,555,1,0,0,0,558,556,1,0,0,0,558,557,1,0,0,0,559,
  	45,1,0,0,0,560,561,5,11,0,0,561,47,1,0,0,0,562,563,5,14,0,0,563,49,1,
  	0,0,0,564,566,5,37,0,0,565,567,3,214,107,0,566,565,1,0,0,0,566,567,1,
  	0,0,0,567,51,1,0,0,0,568,569,3,232,116,0,569,53,1,0,0,0,570,576,5,36,
  	0,0,571,574,3,174,87,0,572,573,5,23,0,0,573,575,3,174,87,0,574,572,1,
  	0,0,0,574,575,1,0,0,0,575,577,1,0,0,0,576,571,1,0,0,0,576,577,1,0,0,0,
  	577,55,1,0,0,0,578,581,3,58,29,0,579,581,3,60,30,0,580,578,1,0,0,0,580,
  	579,1,0,0,0,581,57,1,0,0,0,582,583,5,26,0,0,583,584,3,68,34,0,584,59,
  	1,0,0,0,585,598,5,23,0,0,586,588,7,1,0,0,587,586,1,0,0,0,588,591,1,0,
  	0,0,589,587,1,0,0,0,589,590,1,0,0,0,590,592,1,0,0,0,591,589,1,0,0,0,592,
  	599,3,70,35,0,593,595,7,1,0,0,594,593,1,0,0,0,595,596,1,0,0,0,596,594,
  	1,0,0,0,596,597,1,0,0,0,597,599,1,0,0,0,598,589,1,0,0,0,598,594,1,0,0,
  	0,599,600,1,0,0,0,600,607,5,26,0,0,601,608,5,56,0,0,602,603,5,57,0,0,
  	603,604,3,66,33,0,604,605,5,58,0,0,605,608,1,0,0,0,606,608,3,66,33,0,
  	607,601,1,0,0,0,607,602,1,0,0,0,607,606,1,0,0,0,608,61,1,0,0,0,609,612,
  	3,200,100,0,610,611,5,7,0,0,611,613,3,200,100,0,612,610,1,0,0,0,612,613,
  	1,0,0,0,613,63,1,0,0,0,614,617,3,70,35,0,615,616,5,7,0,0,616,618,3,200,
  	100,0,617,615,1,0,0,0,617,618,1,0,0,0,618,65,1,0,0,0,619,624,3,62,31,
  	0,620,621,5,59,0,0,621,623,3,62,31,0,622,620,1,0,0,0,623,626,1,0,0,0,
  	624,622,1,0,0,0,624,625,1,0,0,0,625,628,1,0,0,0,626,624,1,0,0,0,627,629,
  	5,59,0,0,628,627,1,0,0,0,628,629,1,0,0,0,629,67,1,0,0,0,630,635,3,64,
  	32,0,631,632,5,59,0,0,632,634,3,64,32,0,633,631,1,0,0,0,634,637,1,0,0,
  	0,635,633,1,0,0,0,635,636,1,0,0,0,636,69,1,0,0,0,637,635,1,0,0,0,638,
  	643,3,200,100,0,639,640,5,54,0,0,640,642,3,200,100,0,641,639,1,0,0,0,
  	642,645,1,0,0,0,643,641,1,0,0,0,643,644,1,0,0,0,644,71,1,0,0,0,645,643,
  	1,0,0,0,646,647,5,24,0,0,647,652,3,200,100,0,648,649,5,59,0,0,649,651,
  	3,200,100,0,650,648,1,0,0,0,651,654,1,0,0,0,652,650,1,0,0,0,652,653,1,
  	0,0,0,653,73,1,0,0,0,654,652,1,0,0,0,655,656,5,32,0,0,656,661,3,200,100,
  	0,657,658,5,59,0,0,658,660,3,200,100,0,659,657,1,0,0,0,660,663,1,0,0,
  	0,661,659,1,0,0,0,661,662,1,0,0,0,662,75,1,0,0,0,663,661,1,0,0,0,664,
  	665,5,8,0,0,665,668,3,174,87,0,666,667,5,59,0,0,667,669,3,174,87,0,668,
  	666,1,0,0,0,668,669,1,0,0,0,669,77,1,0,0,0,670,681,3,82,41,0,671,681,
  	3,84,42,0,672,681,3,86,43,0,673,681,3,88,44,0,674,681,3,90,45,0,675,681,
  	3,14,7,0,676,681,3,218,109,0,677,681,3,10,5,0,678,681,3,80,40,0,679,681,
  	3,98,49,0,680,670,1,0,0,0,680,671,1,0,0,0,680,672,1,0,0,0,680,673,1,0,
  	0,0,680,674,1,0,0,0,680,675,1,0,0,0,680,676,1,0,0,0,680,677,1,0,0,0,680,
  	678,1,0,0,0,680,679,1,0,0,0,681,79,1,0,0,0,682,686,5,9,0,0,683,687,3,
  	14,7,0,684,687,3,90,45,0,685,687,3,86,43,0,686,683,1,0,0,0,686,684,1,
  	0,0,0,686,685,1,0,0,0,687,81,1,0,0,0,688,689,5,25,0,0,689,690,3,174,87,
  	0,690,691,5,60,0,0,691,699,3,96,48,0,692,693,5,17,0,0,693,694,3,174,87,
  	0,694,695,5,60,0,0,695,696,3,96,48,0,696,698,1,0,0,0,697,692,1,0,0,0,
  	698,701,1,0,0,0,699,697,1,0,0,0,699,700,1,0,0,0,700,705,1,0,0,0,701,699,
  	1,0,0,0,702,703,5,18,0,0,703,704,5,60,0,0,704,706,3,96,48,0,705,702,1,
  	0,0,0,705,706,1,0,0,0,706,83,1,0,0,0,707,708,5,41,0,0,708,709,3,174,87,
  	0,709,710,5,60,0,0,710,714,3,96,48,0,711,712,5,18,0,0,712,713,5,60,0,
  	0,713,715,3,96,48,0,714,711,1,0,0,0,714,715,1,0,0,0,715,85,1,0,0,0,716,
  	717,5,22,0,0,717,718,3,212,106,0,718,719,5,27,0,0,719,720,3,214,107,0,
  	720,721,5,60,0,0,721,725,3,96,48,0,722,723,5,18,0,0,723,724,5,60,0,0,
  	724,726,3,96,48,0,725,722,1,0,0,0,725,726,1,0,0,0,726,87,1,0,0,0,727,
  	728,5,39,0,0,728,729,5,60,0,0,729,751,3,96,48,0,730,731,3,94,47,0,731,
  	732,5,60,0,0,732,733,3,96,48,0,733,735,1,0,0,0,734,730,1,0,0,0,735,736,
  	1,0,0,0,736,734,1,0,0,0,736,737,1,0,0,0,737,741,1,0,0,0,738,739,5,18,
  	0,0,739,740,5,60,0,0,740,742,3,96,48,0,741,738,1,0,0,0,741,742,1,0,0,
  	0,742,746,1,0,0,0,743,744,5,21,0,0,744,745,5,60,0,0,745,747,3,96,48,0,
  	746,743,1,0,0,0,746,747,1,0,0,0,747,752,1,0,0,0,748,749,5,21,0,0,749,
  	750,5,60,0,0,750,752,3,96,48,0,751,734,1,0,0,0,751,748,1,0,0,0,752,89,
  	1,0,0,0,753,754,5,42,0,0,754,759,3,92,46,0,755,756,5,59,0,0,756,758,3,
  	92,46,0,757,755,1,0,0,0,758,761,1,0,0,0,759,757,1,0,0,0,759,760,1,0,0,
  	0,760,762,1,0,0,0,761,759,1,0,0,0,762,763,5,60,0,0,763,764,3,96,48,0,
  	764,91,1,0,0,0,765,768,3,174,87,0,766,767,5,7,0,0,767,769,3,194,97,0,
  	768,766,1,0,0,0,768,769,1,0,0,0,769,93,1,0,0,0,770,776,5,19,0,0,771,774,
  	3,174,87,0,772,773,5,7,0,0,773,775,3,200,100,0,774,772,1,0,0,0,774,775,
  	1,0,0,0,775,777,1,0,0,0,776,771,1,0,0,0,776,777,1,0,0,0,777,95,1,0,0,
  	0,778,789,3,28,14,0,779,780,5,44,0,0,780,782,5,1,0,0,781,783,3,26,13,
  	0,782,781,1,0,0,0,783,784,1,0,0,0,784,782,1,0,0,0,784,785,1,0,0,0,785,
  	786,1,0,0,0,786,787,5,2,0,0,787,789,1,0,0,0,788,778,1,0,0,0,788,779,1,
  	0,0,0,789,97,1,0,0,0,790,791,5,30,0,0,791,792,3,100,50,0,792,793,5,60,
  	0,0,793,794,5,44,0,0,794,796,5,1,0,0,795,797,3,106,53,0,796,795,1,0,0,
  	0,797,798,1,0,0,0,798,796,1,0,0,0,798,799,1,0,0,0,799,800,1,0,0,0,800,
  	801,5,2,0,0,801,99,1,0,0,0,802,803,3,104,52,0,803,805,5,59,0,0,804,806,
  	3,102,51,0,805,804,1,0,0,0,805,806,1,0,0,0,806,809,1,0,0,0,807,809,3,
  	174,87,0,808,802,1,0,0,0,808,807,1,0,0,0,809,101,1,0,0,0,810,812,5,59,
  	0,0,811,813,3,104,52,0,812,811,1,0,0,0,813,814,1,0,0,0,814,812,1,0,0,
  	0,814,815,1,0,0,0,815,817,1,0,0,0,816,818,5,59,0,0,817,816,1,0,0,0,817,
  	818,1,0,0,0,818,103,1,0,0,0,819,820,5,56,0,0,820,823,3,194,97,0,821,823,
  	3,174,87,0,822,819,1,0,0,0,822,821,1,0,0,0,823,105,1,0,0,0,824,825,5,
  	12,0,0,825,827,3,110,55,0,826,828,3,108,54,0,827,826,1,0,0,0,827,828,
  	1,0,0,0,828,829,1,0,0,0,829,830,5,60,0,0,830,831,3,96,48,0,831,107,1,
  	0,0,0,832,833,5,25,0,0,833,834,3,174,87,0,834,109,1,0,0,0,835,838,3,150,
  	75,0,836,838,3,112,56,0,837,835,1,0,0,0,837,836,1,0,0,0,838,111,1,0,0,
  	0,839,842,3,114,57,0,840,842,3,116,58,0,841,839,1,0,0,0,841,840,1,0,0,
  	0,842,113,1,0,0,0,843,844,3,116,58,0,844,845,5,7,0,0,845,846,3,136,68,
  	0,846,115,1,0,0,0,847,852,3,118,59,0,848,849,5,66,0,0,849,851,3,118,59,
  	0,850,848,1,0,0,0,851,854,1,0,0,0,852,850,1,0,0,0,852,853,1,0,0,0,853,
  	117,1,0,0,0,854,852,1,0,0,0,855,864,3,120,60,0,856,864,3,134,67,0,857,
  	864,3,138,69,0,858,864,3,140,70,0,859,864,3,146,73,0,860,864,3,148,74,
  	0,861,864,3,158,79,0,862,864,3,166,83,0,863,855,1,0,0,0,863,856,1,0,0,
  	0,863,857,1,0,0,0,863,858,1,0,0,0,863,859,1,0,0,0,863,860,1,0,0,0,863,
  	861,1,0,0,0,863,862,1,0,0,0,864,119,1,0,0,0,865,866,3,126,63,0,866,867,
  	4,60,0,0,867,874,1,0,0,0,868,874,3,124,62,0,869,874,3,236,118,0,870,874,
  	5,31,0,0,871,874,5,38,0,0,872,874,5,20,0,0,873,865,1,0,0,0,873,868,1,
  	0,0,0,873,869,1,0,0,0,873,870,1,0,0,0,873,871,1,0,0,0,873,872,1,0,0,0,
  	874,121,1,0,0,0,875,876,3,126,63,0,876,877,4,61,1,0,877,884,1,0,0,0,878,
  	884,3,124,62,0,879,884,3,236,118,0,880,884,5,31,0,0,881,884,5,38,0,0,
  	882,884,5,20,0,0,883,875,1,0,0,0,883,878,1,0,0,0,883,879,1,0,0,0,883,
  	880,1,0,0,0,883,881,1,0,0,0,883,882,1,0,0,0,884,123,1,0,0,0,885,886,3,
  	128,64,0,886,887,5,71,0,0,887,888,3,132,66,0,888,894,1,0,0,0,889,890,
  	3,128,64,0,890,891,5,72,0,0,891,892,3,132,66,0,892,894,1,0,0,0,893,885,
  	1,0,0,0,893,889,1,0,0,0,894,125,1,0,0,0,895,899,5,4,0,0,896,897,5,72,
  	0,0,897,899,5,4,0,0,898,895,1,0,0,0,898,896,1,0,0,0,899,127,1,0,0,0,900,
  	904,3,130,65,0,901,902,5,72,0,0,902,904,3,130,65,0,903,900,1,0,0,0,903,
  	901,1,0,0,0,904,129,1,0,0,0,905,906,5,4,0,0,906,131,1,0,0,0,907,908,5,
  	4,0,0,908,133,1,0,0,0,909,910,3,136,68,0,910,135,1,0,0,0,911,912,3,200,
  	100,0,912,913,4,68,2,0,913,137,1,0,0,0,914,915,5,40,0,0,915,139,1,0,0,
  	0,916,917,3,142,71,0,917,918,4,70,3,0,918,141,1,0,0,0,919,922,3,200,100,
  	0,920,921,5,54,0,0,921,923,3,200,100,0,922,920,1,0,0,0,923,924,1,0,0,
  	0,924,922,1,0,0,0,924,925,1,0,0,0,925,143,1,0,0,0,926,929,3,142,71,0,
  	927,929,3,200,100,0,928,926,1,0,0,0,928,927,1,0,0,0,929,145,1,0,0,0,930,
  	931,5,57,0,0,931,932,3,112,56,0,932,933,5,58,0,0,933,147,1,0,0,0,934,
  	936,5,64,0,0,935,937,3,152,76,0,936,935,1,0,0,0,936,937,1,0,0,0,937,938,
  	1,0,0,0,938,945,5,65,0,0,939,941,5,57,0,0,940,942,3,150,75,0,941,940,
  	1,0,0,0,941,942,1,0,0,0,942,943,1,0,0,0,943,945,5,58,0,0,944,934,1,0,
  	0,0,944,939,1,0,0,0,945,149,1,0,0,0,946,947,3,154,77,0,947,949,5,59,0,
  	0,948,950,3,152,76,0,949,948,1,0,0,0,949,950,1,0,0,0,950,151,1,0,0,0,
  	951,956,3,154,77,0,952,953,5,59,0,0,953,955,3,154,77,0,954,952,1,0,0,
  	0,955,958,1,0,0,0,956,954,1,0,0,0,956,957,1,0,0,0,957,960,1,0,0,0,958,
  	956,1,0,0,0,959,961,5,59,0,0,960,959,1,0,0,0,960,961,1,0,0,0,961,153,
  	1,0,0,0,962,965,3,156,78,0,963,965,3,112,56,0,964,962,1,0,0,0,964,963,
  	1,0,0,0,965,155,1,0,0,0,966,967,5,56,0,0,967,971,3,136,68,0,968,969,5,
  	56,0,0,969,971,3,138,69,0,970,966,1,0,0,0,970,968,1,0,0,0,971,157,1,0,
  	0,0,972,973,5,77,0,0,973,998,5,78,0,0,974,975,5,77,0,0,975,977,3,164,
  	82,0,976,978,5,59,0,0,977,976,1,0,0,0,977,978,1,0,0,0,978,979,1,0,0,0,
  	979,980,5,78,0,0,980,998,1,0,0,0,981,982,5,77,0,0,982,983,3,160,80,0,
  	983,984,5,59,0,0,984,986,3,164,82,0,985,987,5,59,0,0,986,985,1,0,0,0,
  	986,987,1,0,0,0,987,988,1,0,0,0,988,989,5,78,0,0,989,998,1,0,0,0,990,
  	991,5,77,0,0,991,993,3,160,80,0,992,994,5,59,0,0,993,992,1,0,0,0,993,
  	994,1,0,0,0,994,995,1,0,0,0,995,996,5,78,0,0,996,998,1,0,0,0,997,972,
  	1,0,0,0,997,974,1,0,0,0,997,981,1,0,0,0,997,990,1,0,0,0,998,159,1,0,0,
  	0,999,1004,3,162,81,0,1000,1001,5,59,0,0,1001,1003,3,162,81,0,1002,1000,
  	1,0,0,0,1003,1006,1,0,0,0,1004,1002,1,0,0,0,1004,1005,1,0,0,0,1005,161,
  	1,0,0,0,1006,1004,1,0,0,0,1007,1010,3,122,61,0,1008,1010,3,142,71,0,1009,
  	1007,1,0,0,0,1009,1008,1,0,0,0,1010,1011,1,0,0,0,1011,1012,5,60,0,0,1012,
  	1013,3,112,56,0,1013,163,1,0,0,0,1014,1015,5,62,0,0,1015,1016,3,136,68,
  	0,1016,165,1,0,0,0,1017,1018,3,144,72,0,1018,1019,5,57,0,0,1019,1020,
  	5,58,0,0,1020,1048,1,0,0,0,1021,1022,3,144,72,0,1022,1023,5,57,0,0,1023,
  	1025,3,168,84,0,1024,1026,5,59,0,0,1025,1024,1,0,0,0,1025,1026,1,0,0,
  	0,1026,1027,1,0,0,0,1027,1028,5,58,0,0,1028,1048,1,0,0,0,1029,1030,3,
  	144,72,0,1030,1031,5,57,0,0,1031,1033,3,170,85,0,1032,1034,5,59,0,0,1033,
  	1032,1,0,0,0,1033,1034,1,0,0,0,1034,1035,1,0,0,0,1035,1036,5,58,0,0,1036,
  	1048,1,0,0,0,1037,1038,3,144,72,0,1038,1039,5,57,0,0,1039,1040,3,168,
  	84,0,1040,1041,5,59,0,0,1041,1043,3,170,85,0,1042,1044,5,59,0,0,1043,
  	1042,1,0,0,0,1043,1044,1,0,0,0,1044,1045,1,0,0,0,1045,1046,5,58,0,0,1046,
  	1048,1,0,0,0,1047,1017,1,0,0,0,1047,1021,1,0,0,0,1047,1029,1,0,0,0,1047,
  	1037,1,0,0,0,1048,167,1,0,0,0,1049,1054,3,112,56,0,1050,1051,5,59,0,0,
  	1051,1053,3,112,56,0,1052,1050,1,0,0,0,1053,1056,1,0,0,0,1054,1052,1,
  	0,0,0,1054,1055,1,0,0,0,1055,169,1,0,0,0,1056,1054,1,0,0,0,1057,1062,
  	3,172,86,0,1058,1059,5,59,0,0,1059,1061,3,172,86,0,1060,1058,1,0,0,0,
  	1061,1064,1,0,0,0,1062,1060,1,0,0,0,1062,1063,1,0,0,0,1063,171,1,0,0,
  	0,1064,1062,1,0,0,0,1065,1066,3,200,100,0,1066,1067,5,63,0,0,1067,1068,
  	3,112,56,0,1068,173,1,0,0,0,1069,1075,3,182,91,0,1070,1071,5,25,0,0,1071,
  	1072,3,182,91,0,1072,1073,5,18,0,0,1073,1074,3,174,87,0,1074,1076,1,0,
  	0,0,1075,1070,1,0,0,0,1075,1076,1,0,0,0,1076,1079,1,0,0,0,1077,1079,3,
  	178,89,0,1078,1069,1,0,0,0,1078,1077,1,0,0,0,1079,175,1,0,0,0,1080,1083,
  	3,182,91,0,1081,1083,3,180,90,0,1082,1080,1,0,0,0,1082,1081,1,0,0,0,1083,
  	177,1,0,0,0,1084,1086,5,29,0,0,1085,1087,3,22,11,0,1086,1085,1,0,0,0,
  	1086,1087,1,0,0,0,1087,1088,1,0,0,0,1088,1089,5,60,0,0,1089,1090,3,174,
  	87,0,1090,179,1,0,0,0,1091,1093,5,29,0,0,1092,1094,3,22,11,0,1093,1092,
  	1,0,0,0,1093,1094,1,0,0,0,1094,1095,1,0,0,0,1095,1096,5,60,0,0,1096,1097,
  	3,176,88,0,1097,181,1,0,0,0,1098,1103,3,184,92,0,1099,1100,5,34,0,0,1100,
  	1102,3,184,92,0,1101,1099,1,0,0,0,1102,1105,1,0,0,0,1103,1101,1,0,0,0,
  	1103,1104,1,0,0,0,1104,183,1,0,0,0,1105,1103,1,0,0,0,1106,1111,3,186,
  	93,0,1107,1108,5,6,0,0,1108,1110,3,186,93,0,1109,1107,1,0,0,0,1110,1113,
  	1,0,0,0,1111,1109,1,0,0,0,1111,1112,1,0,0,0,1112,185,1,0,0,0,1113,1111,
  	1,0,0,0,1114,1115,5,33,0,0,1115,1118,3,186,93,0,1116,1118,3,188,94,0,
  	1117,1114,1,0,0,0,1117,1116,1,0,0,0,1118,187,1,0,0,0,1119,1125,3,194,
  	97,0,1120,1121,3,190,95,0,1121,1122,3,194,97,0,1122,1124,1,0,0,0,1123,
  	1120,1,0,0,0,1124,1127,1,0,0,0,1125,1123,1,0,0,0,1125,1126,1,0,0,0,1126,
  	189,1,0,0,0,1127,1125,1,0,0,0,1128,1142,5,79,0,0,1129,1142,5,80,0,0,1130,
  	1142,5,81,0,0,1131,1142,5,82,0,0,1132,1142,5,83,0,0,1133,1142,5,84,0,
  	0,1134,1142,5,85,0,0,1135,1142,5,27,0,0,1136,1137,5,33,0,0,1137,1142,
  	5,27,0,0,1138,1142,5,28,0,0,1139,1140,5,28,0,0,1140,1142,5,33,0,0,1141,
  	1128,1,0,0,0,1141,1129,1,0,0,0,1141,1130,1,0,0,0,1141,1131,1,0,0,0,1141,
  	1132,1,0,0,0,1141,1133,1,0,0,0,1141,1134,1,0,0,0,1141,1135,1,0,0,0,1141,
  	1136,1,0,0,0,1141,1138,1,0,0,0,1141,1139,1,0,0,0,1142,191,1,0,0,0,1143,
  	1144,5,56,0,0,1144,1145,3,194,97,0,1145,193,1,0,0,0,1146,1147,6,97,-1,
  	0,1147,1155,3,196,98,0,1148,1150,7,2,0,0,1149,1148,1,0,0,0,1150,1151,
  	1,0,0,0,1151,1149,1,0,0,0,1151,1152,1,0,0,0,1152,1153,1,0,0,0,1153,1155,
  	3,194,97,7,1154,1146,1,0,0,0,1154,1149,1,0,0,0,1155,1179,1,0,0,0,1156,
  	1157,10,8,0,0,1157,1158,5,62,0,0,1158,1178,3,194,97,9,1159,1160,10,6,
  	0,0,1160,1161,7,3,0,0,1161,1178,3,194,97,7,1162,1163,10,5,0,0,1163,1164,
  	7,4,0,0,1164,1178,3,194,97,6,1165,1166,10,4,0,0,1166,1167,7,5,0,0,1167,
  	1178,3,194,97,5,1168,1169,10,3,0,0,1169,1170,5,68,0,0,1170,1178,3,194,
  	97,4,1171,1172,10,2,0,0,1172,1173,5,67,0,0,1173,1178,3,194,97,3,1174,
  	1175,10,1,0,0,1175,1176,5,66,0,0,1176,1178,3,194,97,2,1177,1156,1,0,0,
  	0,1177,1159,1,0,0,0,1177,1162,1,0,0,0,1177,1165,1,0,0,0,1177,1168,1,0,
  	0,0,1177,1171,1,0,0,0,1177,1174,1,0,0,0,1178,1181,1,0,0,0,1179,1177,1,
  	0,0,0,1179,1180,1,0,0,0,1180,195,1,0,0,0,1181,1179,1,0,0,0,1182,1184,
  	5,10,0,0,1183,1182,1,0,0,0,1183,1184,1,0,0,0,1184,1185,1,0,0,0,1185,1189,
  	3,198,99,0,1186,1188,3,204,102,0,1187,1186,1,0,0,0,1188,1191,1,0,0,0,
  	1189,1187,1,0,0,0,1189,1190,1,0,0,0,1190,197,1,0,0,0,1191,1189,1,0,0,
  	0,1192,1195,5,57,0,0,1193,1196,3,232,116,0,1194,1196,3,202,101,0,1195,
  	1193,1,0,0,0,1195,1194,1,0,0,0,1195,1196,1,0,0,0,1196,1197,1,0,0,0,1197,
  	1220,5,58,0,0,1198,1200,5,64,0,0,1199,1201,3,202,101,0,1200,1199,1,0,
  	0,0,1200,1201,1,0,0,0,1201,1202,1,0,0,0,1202,1220,5,65,0,0,1203,1205,
  	5,77,0,0,1204,1206,3,216,108,0,1205,1204,1,0,0,0,1205,1206,1,0,0,0,1206,
  	1207,1,0,0,0,1207,1220,5,78,0,0,1208,1220,3,200,100,0,1209,1220,5,4,0,
  	0,1210,1212,5,3,0,0,1211,1210,1,0,0,0,1212,1213,1,0,0,0,1213,1211,1,0,
  	0,0,1213,1214,1,0,0,0,1214,1220,1,0,0,0,1215,1220,5,55,0,0,1216,1220,
  	5,31,0,0,1217,1220,5,38,0,0,1218,1220,5,20,0,0,1219,1192,1,0,0,0,1219,
  	1198,1,0,0,0,1219,1203,1,0,0,0,1219,1208,1,0,0,0,1219,1209,1,0,0,0,1219,
  	1211,1,0,0,0,1219,1215,1,0,0,0,1219,1216,1,0,0,0,1219,1217,1,0,0,0,1219,
  	1218,1,0,0,0,1220,199,1,0,0,0,1221,1222,7,6,0,0,1222,201,1,0,0,0,1223,
  	1226,3,174,87,0,1224,1226,3,192,96,0,1225,1223,1,0,0,0,1225,1224,1,0,
  	0,0,1226,1241,1,0,0,0,1227,1242,3,226,113,0,1228,1231,5,59,0,0,1229,1232,
  	3,174,87,0,1230,1232,3,192,96,0,1231,1229,1,0,0,0,1231,1230,1,0,0,0,1232,
  	1234,1,0,0,0,1233,1228,1,0,0,0,1234,1237,1,0,0,0,1235,1233,1,0,0,0,1235,
  	1236,1,0,0,0,1236,1239,1,0,0,0,1237,1235,1,0,0,0,1238,1240,5,59,0,0,1239,
  	1238,1,0,0,0,1239,1240,1,0,0,0,1240,1242,1,0,0,0,1241,1227,1,0,0,0,1241,
  	1235,1,0,0,0,1242,203,1,0,0,0,1243,1245,5,57,0,0,1244,1246,3,220,110,
  	0,1245,1244,1,0,0,0,1245,1246,1,0,0,0,1246,1247,1,0,0,0,1247,1255,5,58,
  	0,0,1248,1249,5,64,0,0,1249,1250,3,206,103,0,1250,1251,5,65,0,0,1251,
  	1255,1,0,0,0,1252,1253,5,54,0,0,1253,1255,3,200,100,0,1254,1243,1,0,0,
  	0,1254,1248,1,0,0,0,1254,1252,1,0,0,0,1255,205,1,0,0,0,1256,1261,3,208,
  	104,0,1257,1258,5,59,0,0,1258,1260,3,208,104,0,1259,1257,1,0,0,0,1260,
  	1263,1,0,0,0,1261,1259,1,0,0,0,1261,1262,1,0,0,0,1262,1265,1,0,0,0,1263,
  	1261,1,0,0,0,1264,1266,5,59,0,0,1265,1264,1,0,0,0,1265,1266,1,0,0,0,1266,
  	207,1,0,0,0,1267,1279,3,174,87,0,1268,1270,3,174,87,0,1269,1268,1,0,0,
  	0,1269,1270,1,0,0,0,1270,1271,1,0,0,0,1271,1273,5,60,0,0,1272,1274,3,
  	174,87,0,1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,1276,1,0,0,0,1275,1277,
  	3,210,105,0,1276,1275,1,0,0,0,1276,1277,1,0,0,0,1277,1279,1,0,0,0,1278,
  	1267,1,0,0,0,1278,1269,1,0,0,0,1279,209,1,0,0,0,1280,1282,5,60,0,0,1281,
  	1283,3,174,87,0,1282,1281,1,0,0,0,1282,1283,1,0,0,0,1283,211,1,0,0,0,
  	1284,1287,3,194,97,0,1285,1287,3,192,96,0,1286,1284,1,0,0,0,1286,1285,
  	1,0,0,0,1287,1295,1,0,0,0,1288,1291,5,59,0,0,1289,1292,3,194,97,0,1290,
  	1292,3,192,96,0,1291,1289,1,0,0,0,1291,1290,1,0,0,0,1292,1294,1,0,0,0,
  	1293,1288,1,0,0,0,1294,1297,1,0,0,0,1295,1293,1,0,0,0,1295,1296,1,0,0,
  	0,1296,1299,1,0,0,0,1297,1295,1,0,0,0,1298,1300,5,59,0,0,1299,1298,1,
  	0,0,0,1299,1300,1,0,0,0,1300,213,1,0,0,0,1301,1306,3,174,87,0,1302,1303,
  	5,59,0,0,1303,1305,3,174,87,0,1304,1302,1,0,0,0,1305,1308,1,0,0,0,1306,
  	1304,1,0,0,0,1306,1307,1,0,0,0,1307,1310,1,0,0,0,1308,1306,1,0,0,0,1309,
  	1311,5,59,0,0,1310,1309,1,0,0,0,1310,1311,1,0,0,0,1311,215,1,0,0,0,1312,
  	1313,3,174,87,0,1313,1314,5,60,0,0,1314,1315,3,174,87,0,1315,1319,1,0,
  	0,0,1316,1317,5,62,0,0,1317,1319,3,194,97,0,1318,1312,1,0,0,0,1318,1316,
  	1,0,0,0,1319,1338,1,0,0,0,1320,1339,3,226,113,0,1321,1328,5,59,0,0,1322,
  	1323,3,174,87,0,1323,1324,5,60,0,0,1324,1325,3,174,87,0,1325,1329,1,0,
  	0,0,1326,1327,5,62,0,0,1327,1329,3,194,97,0,1328,1322,1,0,0,0,1328,1326,
  	1,0,0,0,1329,1331,1,0,0,0,1330,1321,1,0,0,0,1331,1334,1,0,0,0,1332,1330,
  	1,0,0,0,1332,1333,1,0,0,0,1333,1336,1,0,0,0,1334,1332,1,0,0,0,1335,1337,
  	5,59,0,0,1336,1335,1,0,0,0,1336,1337,1,0,0,0,1337,1339,1,0,0,0,1338,1320,
  	1,0,0,0,1338,1332,1,0,0,0,1339,1361,1,0,0,0,1340,1343,3,174,87,0,1341,
  	1343,3,192,96,0,1342,1340,1,0,0,0,1342,1341,1,0,0,0,1343,1358,1,0,0,0,
  	1344,1359,3,226,113,0,1345,1348,5,59,0,0,1346,1349,3,174,87,0,1347,1349,
  	3,192,96,0,1348,1346,1,0,0,0,1348,1347,1,0,0,0,1349,1351,1,0,0,0,1350,
  	1345,1,0,0,0,1351,1354,1,0,0,0,1352,1350,1,0,0,0,1352,1353,1,0,0,0,1353,
  	1356,1,0,0,0,1354,1352,1,0,0,0,1355,1357,5,59,0,0,1356,1355,1,0,0,0,1356,
  	1357,1,0,0,0,1357,1359,1,0,0,0,1358,1344,1,0,0,0,1358,1352,1,0,0,0,1359,
  	1361,1,0,0,0,1360,1318,1,0,0,0,1360,1342,1,0,0,0,1361,217,1,0,0,0,1362,
  	1363,5,13,0,0,1363,1369,3,200,100,0,1364,1366,5,57,0,0,1365,1367,3,220,
  	110,0,1366,1365,1,0,0,0,1366,1367,1,0,0,0,1367,1368,1,0,0,0,1368,1370,
  	5,58,0,0,1369,1364,1,0,0,0,1369,1370,1,0,0,0,1370,1371,1,0,0,0,1371,1372,
  	5,60,0,0,1372,1373,3,96,48,0,1373,219,1,0,0,0,1374,1379,3,222,111,0,1375,
  	1376,5,59,0,0,1376,1378,3,222,111,0,1377,1375,1,0,0,0,1378,1381,1,0,0,
  	0,1379,1377,1,0,0,0,1379,1380,1,0,0,0,1380,1383,1,0,0,0,1381,1379,1,0,
  	0,0,1382,1384,5,59,0,0,1383,1382,1,0,0,0,1383,1384,1,0,0,0,1384,221,1,
  	0,0,0,1385,1387,3,174,87,0,1386,1388,3,226,113,0,1387,1386,1,0,0,0,1387,
  	1388,1,0,0,0,1388,1398,1,0,0,0,1389,1390,3,174,87,0,1390,1391,5,63,0,
  	0,1391,1392,3,174,87,0,1392,1398,1,0,0,0,1393,1394,5,62,0,0,1394,1398,
  	3,174,87,0,1395,1396,5,56,0,0,1396,1398,3,174,87,0,1397,1385,1,0,0,0,
  	1397,1389,1,0,0,0,1397,1393,1,0,0,0,1397,1395,1,0,0,0,1398,223,1,0,0,
  	0,1399,1402,3,226,113,0,1400,1402,3,228,114,0,1401,1399,1,0,0,0,1401,
  	1400,1,0,0,0,1402,225,1,0,0,0,1403,1405,5,9,0,0,1404,1403,1,0,0,0,1404,
  	1405,1,0,0,0,1405,1406,1,0,0,0,1406,1407,5,22,0,0,1407,1408,3,212,106,
  	0,1408,1409,5,27,0,0,1409,1411,3,182,91,0,1410,1412,3,224,112,0,1411,
  	1410,1,0,0,0,1411,1412,1,0,0,0,1412,227,1,0,0,0,1413,1414,5,25,0,0,1414,
  	1416,3,176,88,0,1415,1417,3,224,112,0,1416,1415,1,0,0,0,1416,1417,1,0,
  	0,0,1417,229,1,0,0,0,1418,1419,3,200,100,0,1419,231,1,0,0,0,1420,1422,
  	5,43,0,0,1421,1423,3,234,117,0,1422,1421,1,0,0,0,1422,1423,1,0,0,0,1423,
  	233,1,0,0,0,1424,1425,5,23,0,0,1425,1428,3,174,87,0,1426,1428,3,214,107,
  	0,1427,1424,1,0,0,0,1427,1426,1,0,0,0,1428,235,1,0,0,0,1429,1431,5,3,
  	0,0,1430,1429,1,0,0,0,1431,1432,1,0,0,0,1432,1430,1,0,0,0,1432,1433,1,
  	0,0,0,1433,237,1,0,0,0,201,243,247,249,258,267,270,277,283,293,300,307,
  	313,317,323,329,333,340,342,344,349,351,353,357,363,367,374,376,378,383,
  	385,390,395,401,405,411,417,421,428,430,432,437,439,441,445,451,455,462,
  	464,466,471,473,479,486,490,502,509,514,518,521,527,531,536,540,544,558,
  	566,574,576,580,589,596,598,607,612,617,624,628,635,643,652,661,668,680,
  	686,699,705,714,725,736,741,746,751,759,768,774,776,784,788,798,805,808,
  	814,817,822,827,837,841,852,863,873,883,893,898,903,924,928,936,941,944,
  	949,956,960,964,970,977,986,993,997,1004,1009,1025,1033,1043,1047,1054,
  	1062,1075,1078,1082,1086,1093,1103,1111,1117,1125,1141,1151,1154,1177,
  	1179,1183,1189,1195,1200,1205,1213,1219,1225,1231,1235,1239,1241,1245,
  	1254,1261,1265,1269,1273,1276,1278,1282,1286,1291,1295,1299,1306,1310,
  	1318,1328,1332,1336,1338,1342,1348,1352,1356,1358,1360,1366,1369,1379,
  	1383,1387,1397,1401,1404,1411,1416,1422,1427,1432
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  python3parserParserStaticData = staticData.release();
}

}

Python3Parser::Python3Parser(TokenStream *input) : Python3Parser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

Python3Parser::Python3Parser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Python3ParserBase(input) {
  Python3Parser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *python3parserParserStaticData->atn, python3parserParserStaticData->decisionToDFA, python3parserParserStaticData->sharedContextCache, options);
}

Python3Parser::~Python3Parser() {
  delete _interpreter;
}

const atn::ATN& Python3Parser::getATN() const {
  return *python3parserParserStaticData->atn;
}

std::string Python3Parser::getGrammarFileName() const {
  return "Python3Parser.g4";
}

const std::vector<std::string>& Python3Parser::getRuleNames() const {
  return python3parserParserStaticData->ruleNames;
}

const dfa::Vocabulary& Python3Parser::getVocabulary() const {
  return python3parserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView Python3Parser::getSerializedATN() const {
  return python3parserParserStaticData->serializedATN;
}


//----------------- Single_inputContext ------------------------------------------------------------------

Python3Parser::Single_inputContext::Single_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Single_inputContext::NEWLINE() {
  return getToken(Python3Parser::NEWLINE, 0);
}

Python3Parser::Simple_stmtsContext* Python3Parser::Single_inputContext::simple_stmts() {
  return getRuleContext<Python3Parser::Simple_stmtsContext>(0);
}

Python3Parser::Compound_stmtContext* Python3Parser::Single_inputContext::compound_stmt() {
  return getRuleContext<Python3Parser::Compound_stmtContext>(0);
}


size_t Python3Parser::Single_inputContext::getRuleIndex() const {
  return Python3Parser::RuleSingle_input;
}

void Python3Parser::Single_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingle_input(this);
}

void Python3Parser::Single_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingle_input(this);
}


std::any Python3Parser::Single_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSingle_input(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Single_inputContext* Python3Parser::single_input() {
  Single_inputContext *_localctx = _tracker.createInstance<Single_inputContext>(_ctx, getState());
  enterRule(_localctx, 0, Python3Parser::RuleSingle_input);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(243);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(238);
      match(Python3Parser::NEWLINE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(239);
      simple_stmts();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(240);
      compound_stmt();
      setState(241);
      match(Python3Parser::NEWLINE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_inputContext ------------------------------------------------------------------

Python3Parser::File_inputContext::File_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::File_inputContext::EOF() {
  return getToken(Python3Parser::EOF, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::File_inputContext::NEWLINE() {
  return getTokens(Python3Parser::NEWLINE);
}

tree::TerminalNode* Python3Parser::File_inputContext::NEWLINE(size_t i) {
  return getToken(Python3Parser::NEWLINE, i);
}

std::vector<Python3Parser::StmtContext *> Python3Parser::File_inputContext::stmt() {
  return getRuleContexts<Python3Parser::StmtContext>();
}

Python3Parser::StmtContext* Python3Parser::File_inputContext::stmt(size_t i) {
  return getRuleContext<Python3Parser::StmtContext>(i);
}


size_t Python3Parser::File_inputContext::getRuleIndex() const {
  return Python3Parser::RuleFile_input;
}

void Python3Parser::File_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFile_input(this);
}

void Python3Parser::File_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFile_input(this);
}


std::any Python3Parser::File_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitFile_input(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::File_inputContext* Python3Parser::file_input() {
  File_inputContext *_localctx = _tracker.createInstance<File_inputContext>(_ctx, getState());
  enterRule(_localctx, 2, Python3Parser::RuleFile_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(249);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 252271930291384088) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4206977) != 0)) {
      setState(247);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case Python3Parser::NEWLINE: {
          setState(245);
          match(Python3Parser::NEWLINE);
          break;
        }

        case Python3Parser::STRING:
        case Python3Parser::NUMBER:
        case Python3Parser::ASSERT:
        case Python3Parser::ASYNC:
        case Python3Parser::AWAIT:
        case Python3Parser::BREAK:
        case Python3Parser::CLASS:
        case Python3Parser::CONTINUE:
        case Python3Parser::DEF:
        case Python3Parser::DEL:
        case Python3Parser::FALSE:
        case Python3Parser::FOR:
        case Python3Parser::FROM:
        case Python3Parser::GLOBAL:
        case Python3Parser::IF:
        case Python3Parser::IMPORT:
        case Python3Parser::LAMBDA:
        case Python3Parser::MATCH:
        case Python3Parser::NONE:
        case Python3Parser::NONLOCAL:
        case Python3Parser::NOT:
        case Python3Parser::PASS:
        case Python3Parser::RAISE:
        case Python3Parser::RETURN:
        case Python3Parser::TRUE:
        case Python3Parser::TRY:
        case Python3Parser::UNDERSCORE:
        case Python3Parser::WHILE:
        case Python3Parser::WITH:
        case Python3Parser::YIELD:
        case Python3Parser::NAME:
        case Python3Parser::ELLIPSIS:
        case Python3Parser::STAR:
        case Python3Parser::OPEN_PAREN:
        case Python3Parser::OPEN_BRACK:
        case Python3Parser::ADD:
        case Python3Parser::MINUS:
        case Python3Parser::NOT_OP:
        case Python3Parser::OPEN_BRACE:
        case Python3Parser::AT: {
          setState(246);
          stmt();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(251);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(252);
    match(Python3Parser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Eval_inputContext ------------------------------------------------------------------

Python3Parser::Eval_inputContext::Eval_inputContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::TestlistContext* Python3Parser::Eval_inputContext::testlist() {
  return getRuleContext<Python3Parser::TestlistContext>(0);
}

tree::TerminalNode* Python3Parser::Eval_inputContext::EOF() {
  return getToken(Python3Parser::EOF, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::Eval_inputContext::NEWLINE() {
  return getTokens(Python3Parser::NEWLINE);
}

tree::TerminalNode* Python3Parser::Eval_inputContext::NEWLINE(size_t i) {
  return getToken(Python3Parser::NEWLINE, i);
}


size_t Python3Parser::Eval_inputContext::getRuleIndex() const {
  return Python3Parser::RuleEval_input;
}

void Python3Parser::Eval_inputContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEval_input(this);
}

void Python3Parser::Eval_inputContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEval_input(this);
}


std::any Python3Parser::Eval_inputContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitEval_input(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Eval_inputContext* Python3Parser::eval_input() {
  Eval_inputContext *_localctx = _tracker.createInstance<Eval_inputContext>(_ctx, getState());
  enterRule(_localctx, 4, Python3Parser::RuleEval_input);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(254);
    testlist();
    setState(258);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::NEWLINE) {
      setState(255);
      match(Python3Parser::NEWLINE);
      setState(260);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(261);
    match(Python3Parser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorContext ------------------------------------------------------------------

Python3Parser::DecoratorContext::DecoratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::DecoratorContext::AT() {
  return getToken(Python3Parser::AT, 0);
}

Python3Parser::Dotted_nameContext* Python3Parser::DecoratorContext::dotted_name() {
  return getRuleContext<Python3Parser::Dotted_nameContext>(0);
}

tree::TerminalNode* Python3Parser::DecoratorContext::NEWLINE() {
  return getToken(Python3Parser::NEWLINE, 0);
}

tree::TerminalNode* Python3Parser::DecoratorContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::DecoratorContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::ArglistContext* Python3Parser::DecoratorContext::arglist() {
  return getRuleContext<Python3Parser::ArglistContext>(0);
}


size_t Python3Parser::DecoratorContext::getRuleIndex() const {
  return Python3Parser::RuleDecorator;
}

void Python3Parser::DecoratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorator(this);
}

void Python3Parser::DecoratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorator(this);
}


std::any Python3Parser::DecoratorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDecorator(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::DecoratorContext* Python3Parser::decorator() {
  DecoratorContext *_localctx = _tracker.createInstance<DecoratorContext>(_ctx, getState());
  enterRule(_localctx, 6, Python3Parser::RuleDecorator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    match(Python3Parser::AT);
    setState(264);
    dotted_name();
    setState(270);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::OPEN_PAREN) {
      setState(265);
      match(Python3Parser::OPEN_PAREN);
      setState(267);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4863924168670839832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 12673) != 0)) {
        setState(266);
        arglist();
      }
      setState(269);
      match(Python3Parser::CLOSE_PAREN);
    }
    setState(272);
    match(Python3Parser::NEWLINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratorsContext ------------------------------------------------------------------

Python3Parser::DecoratorsContext::DecoratorsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::DecoratorContext *> Python3Parser::DecoratorsContext::decorator() {
  return getRuleContexts<Python3Parser::DecoratorContext>();
}

Python3Parser::DecoratorContext* Python3Parser::DecoratorsContext::decorator(size_t i) {
  return getRuleContext<Python3Parser::DecoratorContext>(i);
}


size_t Python3Parser::DecoratorsContext::getRuleIndex() const {
  return Python3Parser::RuleDecorators;
}

void Python3Parser::DecoratorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorators(this);
}

void Python3Parser::DecoratorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorators(this);
}


std::any Python3Parser::DecoratorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDecorators(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::DecoratorsContext* Python3Parser::decorators() {
  DecoratorsContext *_localctx = _tracker.createInstance<DecoratorsContext>(_ctx, getState());
  enterRule(_localctx, 8, Python3Parser::RuleDecorators);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(274);
      decorator();
      setState(277); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == Python3Parser::AT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecoratedContext ------------------------------------------------------------------

Python3Parser::DecoratedContext::DecoratedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::DecoratorsContext* Python3Parser::DecoratedContext::decorators() {
  return getRuleContext<Python3Parser::DecoratorsContext>(0);
}

Python3Parser::ClassdefContext* Python3Parser::DecoratedContext::classdef() {
  return getRuleContext<Python3Parser::ClassdefContext>(0);
}

Python3Parser::FuncdefContext* Python3Parser::DecoratedContext::funcdef() {
  return getRuleContext<Python3Parser::FuncdefContext>(0);
}

Python3Parser::Async_funcdefContext* Python3Parser::DecoratedContext::async_funcdef() {
  return getRuleContext<Python3Parser::Async_funcdefContext>(0);
}


size_t Python3Parser::DecoratedContext::getRuleIndex() const {
  return Python3Parser::RuleDecorated;
}

void Python3Parser::DecoratedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecorated(this);
}

void Python3Parser::DecoratedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecorated(this);
}


std::any Python3Parser::DecoratedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDecorated(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::DecoratedContext* Python3Parser::decorated() {
  DecoratedContext *_localctx = _tracker.createInstance<DecoratedContext>(_ctx, getState());
  enterRule(_localctx, 10, Python3Parser::RuleDecorated);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(279);
    decorators();
    setState(283);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::CLASS: {
        setState(280);
        classdef();
        break;
      }

      case Python3Parser::DEF: {
        setState(281);
        funcdef();
        break;
      }

      case Python3Parser::ASYNC: {
        setState(282);
        async_funcdef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Async_funcdefContext ------------------------------------------------------------------

Python3Parser::Async_funcdefContext::Async_funcdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Async_funcdefContext::ASYNC() {
  return getToken(Python3Parser::ASYNC, 0);
}

Python3Parser::FuncdefContext* Python3Parser::Async_funcdefContext::funcdef() {
  return getRuleContext<Python3Parser::FuncdefContext>(0);
}


size_t Python3Parser::Async_funcdefContext::getRuleIndex() const {
  return Python3Parser::RuleAsync_funcdef;
}

void Python3Parser::Async_funcdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsync_funcdef(this);
}

void Python3Parser::Async_funcdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsync_funcdef(this);
}


std::any Python3Parser::Async_funcdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAsync_funcdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Async_funcdefContext* Python3Parser::async_funcdef() {
  Async_funcdefContext *_localctx = _tracker.createInstance<Async_funcdefContext>(_ctx, getState());
  enterRule(_localctx, 12, Python3Parser::RuleAsync_funcdef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(285);
    match(Python3Parser::ASYNC);
    setState(286);
    funcdef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FuncdefContext ------------------------------------------------------------------

Python3Parser::FuncdefContext::FuncdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::FuncdefContext::DEF() {
  return getToken(Python3Parser::DEF, 0);
}

Python3Parser::NameContext* Python3Parser::FuncdefContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}

Python3Parser::ParametersContext* Python3Parser::FuncdefContext::parameters() {
  return getRuleContext<Python3Parser::ParametersContext>(0);
}

tree::TerminalNode* Python3Parser::FuncdefContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::BlockContext* Python3Parser::FuncdefContext::block() {
  return getRuleContext<Python3Parser::BlockContext>(0);
}

tree::TerminalNode* Python3Parser::FuncdefContext::ARROW() {
  return getToken(Python3Parser::ARROW, 0);
}

Python3Parser::TestContext* Python3Parser::FuncdefContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::FuncdefContext::getRuleIndex() const {
  return Python3Parser::RuleFuncdef;
}

void Python3Parser::FuncdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFuncdef(this);
}

void Python3Parser::FuncdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFuncdef(this);
}


std::any Python3Parser::FuncdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitFuncdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::FuncdefContext* Python3Parser::funcdef() {
  FuncdefContext *_localctx = _tracker.createInstance<FuncdefContext>(_ctx, getState());
  enterRule(_localctx, 14, Python3Parser::RuleFuncdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(288);
    match(Python3Parser::DEF);
    setState(289);
    name();
    setState(290);
    parameters();
    setState(293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ARROW) {
      setState(291);
      match(Python3Parser::ARROW);
      setState(292);
      test();
    }
    setState(295);
    match(Python3Parser::COLON);
    setState(296);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParametersContext ------------------------------------------------------------------

Python3Parser::ParametersContext::ParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::ParametersContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::ParametersContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::TypedargslistContext* Python3Parser::ParametersContext::typedargslist() {
  return getRuleContext<Python3Parser::TypedargslistContext>(0);
}


size_t Python3Parser::ParametersContext::getRuleIndex() const {
  return Python3Parser::RuleParameters;
}

void Python3Parser::ParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameters(this);
}

void Python3Parser::ParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameters(this);
}


std::any Python3Parser::ParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitParameters(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ParametersContext* Python3Parser::parameters() {
  ParametersContext *_localctx = _tracker.createInstance<ParametersContext>(_ctx, getState());
  enterRule(_localctx, 16, Python3Parser::RuleParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(Python3Parser::OPEN_PAREN);
    setState(300);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4683779897422774272) != 0)) {
      setState(299);
      typedargslist();
    }
    setState(302);
    match(Python3Parser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedargslistContext ------------------------------------------------------------------

Python3Parser::TypedargslistContext::TypedargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TfpdefContext *> Python3Parser::TypedargslistContext::tfpdef() {
  return getRuleContexts<Python3Parser::TfpdefContext>();
}

Python3Parser::TfpdefContext* Python3Parser::TypedargslistContext::tfpdef(size_t i) {
  return getRuleContext<Python3Parser::TfpdefContext>(i);
}

tree::TerminalNode* Python3Parser::TypedargslistContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

tree::TerminalNode* Python3Parser::TypedargslistContext::POWER() {
  return getToken(Python3Parser::POWER, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::TypedargslistContext::ASSIGN() {
  return getTokens(Python3Parser::ASSIGN);
}

tree::TerminalNode* Python3Parser::TypedargslistContext::ASSIGN(size_t i) {
  return getToken(Python3Parser::ASSIGN, i);
}

std::vector<Python3Parser::TestContext *> Python3Parser::TypedargslistContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::TypedargslistContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::TypedargslistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::TypedargslistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::TypedargslistContext::getRuleIndex() const {
  return Python3Parser::RuleTypedargslist;
}

void Python3Parser::TypedargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedargslist(this);
}

void Python3Parser::TypedargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedargslist(this);
}


std::any Python3Parser::TypedargslistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTypedargslist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::TypedargslistContext* Python3Parser::typedargslist() {
  TypedargslistContext *_localctx = _tracker.createInstance<TypedargslistContext>(_ctx, getState());
  enterRule(_localctx, 18, Python3Parser::RuleTypedargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(385);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::MATCH:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME: {
        setState(304);
        tfpdef();
        setState(307);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::ASSIGN) {
          setState(305);
          match(Python3Parser::ASSIGN);
          setState(306);
          test();
        }
        setState(317);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(309);
            match(Python3Parser::COMMA);
            setState(310);
            tfpdef();
            setState(313);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::ASSIGN) {
              setState(311);
              match(Python3Parser::ASSIGN);
              setState(312);
              test();
            } 
          }
          setState(319);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        }
        setState(353);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(320);
          match(Python3Parser::COMMA);
          setState(351);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case Python3Parser::STAR: {
              setState(321);
              match(Python3Parser::STAR);
              setState(323);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if ((((_la & ~ 0x3fULL) == 0) &&
                ((1ULL << _la) & 36284957458432) != 0)) {
                setState(322);
                tfpdef();
              }
              setState(333);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
              while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                if (alt == 1) {
                  setState(325);
                  match(Python3Parser::COMMA);
                  setState(326);
                  tfpdef();
                  setState(329);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == Python3Parser::ASSIGN) {
                    setState(327);
                    match(Python3Parser::ASSIGN);
                    setState(328);
                    test();
                  } 
                }
                setState(335);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
              }
              setState(344);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == Python3Parser::COMMA) {
                setState(336);
                match(Python3Parser::COMMA);
                setState(342);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == Python3Parser::POWER) {
                  setState(337);
                  match(Python3Parser::POWER);
                  setState(338);
                  tfpdef();
                  setState(340);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == Python3Parser::COMMA) {
                    setState(339);
                    match(Python3Parser::COMMA);
                  }
                }
              }
              break;
            }

            case Python3Parser::POWER: {
              setState(346);
              match(Python3Parser::POWER);
              setState(347);
              tfpdef();
              setState(349);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == Python3Parser::COMMA) {
                setState(348);
                match(Python3Parser::COMMA);
              }
              break;
            }

            case Python3Parser::CLOSE_PAREN: {
              break;
            }

          default:
            break;
          }
        }
        break;
      }

      case Python3Parser::STAR: {
        setState(355);
        match(Python3Parser::STAR);
        setState(357);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 36284957458432) != 0)) {
          setState(356);
          tfpdef();
        }
        setState(367);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(359);
            match(Python3Parser::COMMA);
            setState(360);
            tfpdef();
            setState(363);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::ASSIGN) {
              setState(361);
              match(Python3Parser::ASSIGN);
              setState(362);
              test();
            } 
          }
          setState(369);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        }
        setState(378);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(370);
          match(Python3Parser::COMMA);
          setState(376);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == Python3Parser::POWER) {
            setState(371);
            match(Python3Parser::POWER);
            setState(372);
            tfpdef();
            setState(374);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::COMMA) {
              setState(373);
              match(Python3Parser::COMMA);
            }
          }
        }
        break;
      }

      case Python3Parser::POWER: {
        setState(380);
        match(Python3Parser::POWER);
        setState(381);
        tfpdef();
        setState(383);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(382);
          match(Python3Parser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TfpdefContext ------------------------------------------------------------------

Python3Parser::TfpdefContext::TfpdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::NameContext* Python3Parser::TfpdefContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}

tree::TerminalNode* Python3Parser::TfpdefContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::TestContext* Python3Parser::TfpdefContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::TfpdefContext::getRuleIndex() const {
  return Python3Parser::RuleTfpdef;
}

void Python3Parser::TfpdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTfpdef(this);
}

void Python3Parser::TfpdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTfpdef(this);
}


std::any Python3Parser::TfpdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTfpdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::TfpdefContext* Python3Parser::tfpdef() {
  TfpdefContext *_localctx = _tracker.createInstance<TfpdefContext>(_ctx, getState());
  enterRule(_localctx, 20, Python3Parser::RuleTfpdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(387);
    name();
    setState(390);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COLON) {
      setState(388);
      match(Python3Parser::COLON);
      setState(389);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarargslistContext ------------------------------------------------------------------

Python3Parser::VarargslistContext::VarargslistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::VfpdefContext *> Python3Parser::VarargslistContext::vfpdef() {
  return getRuleContexts<Python3Parser::VfpdefContext>();
}

Python3Parser::VfpdefContext* Python3Parser::VarargslistContext::vfpdef(size_t i) {
  return getRuleContext<Python3Parser::VfpdefContext>(i);
}

tree::TerminalNode* Python3Parser::VarargslistContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

tree::TerminalNode* Python3Parser::VarargslistContext::POWER() {
  return getToken(Python3Parser::POWER, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::VarargslistContext::ASSIGN() {
  return getTokens(Python3Parser::ASSIGN);
}

tree::TerminalNode* Python3Parser::VarargslistContext::ASSIGN(size_t i) {
  return getToken(Python3Parser::ASSIGN, i);
}

std::vector<Python3Parser::TestContext *> Python3Parser::VarargslistContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::VarargslistContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::VarargslistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::VarargslistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::VarargslistContext::getRuleIndex() const {
  return Python3Parser::RuleVarargslist;
}

void Python3Parser::VarargslistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarargslist(this);
}

void Python3Parser::VarargslistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarargslist(this);
}


std::any Python3Parser::VarargslistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitVarargslist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::VarargslistContext* Python3Parser::varargslist() {
  VarargslistContext *_localctx = _tracker.createInstance<VarargslistContext>(_ctx, getState());
  enterRule(_localctx, 22, Python3Parser::RuleVarargslist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(473);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::MATCH:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME: {
        setState(392);
        vfpdef();
        setState(395);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::ASSIGN) {
          setState(393);
          match(Python3Parser::ASSIGN);
          setState(394);
          test();
        }
        setState(405);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(397);
            match(Python3Parser::COMMA);
            setState(398);
            vfpdef();
            setState(401);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::ASSIGN) {
              setState(399);
              match(Python3Parser::ASSIGN);
              setState(400);
              test();
            } 
          }
          setState(407);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
        }
        setState(441);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(408);
          match(Python3Parser::COMMA);
          setState(439);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case Python3Parser::STAR: {
              setState(409);
              match(Python3Parser::STAR);
              setState(411);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if ((((_la & ~ 0x3fULL) == 0) &&
                ((1ULL << _la) & 36284957458432) != 0)) {
                setState(410);
                vfpdef();
              }
              setState(421);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
              while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
                if (alt == 1) {
                  setState(413);
                  match(Python3Parser::COMMA);
                  setState(414);
                  vfpdef();
                  setState(417);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == Python3Parser::ASSIGN) {
                    setState(415);
                    match(Python3Parser::ASSIGN);
                    setState(416);
                    test();
                  } 
                }
                setState(423);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
              }
              setState(432);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == Python3Parser::COMMA) {
                setState(424);
                match(Python3Parser::COMMA);
                setState(430);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == Python3Parser::POWER) {
                  setState(425);
                  match(Python3Parser::POWER);
                  setState(426);
                  vfpdef();
                  setState(428);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == Python3Parser::COMMA) {
                    setState(427);
                    match(Python3Parser::COMMA);
                  }
                }
              }
              break;
            }

            case Python3Parser::POWER: {
              setState(434);
              match(Python3Parser::POWER);
              setState(435);
              vfpdef();
              setState(437);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == Python3Parser::COMMA) {
                setState(436);
                match(Python3Parser::COMMA);
              }
              break;
            }

            case Python3Parser::COLON: {
              break;
            }

          default:
            break;
          }
        }
        break;
      }

      case Python3Parser::STAR: {
        setState(443);
        match(Python3Parser::STAR);
        setState(445);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 36284957458432) != 0)) {
          setState(444);
          vfpdef();
        }
        setState(455);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(447);
            match(Python3Parser::COMMA);
            setState(448);
            vfpdef();
            setState(451);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::ASSIGN) {
              setState(449);
              match(Python3Parser::ASSIGN);
              setState(450);
              test();
            } 
          }
          setState(457);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
        }
        setState(466);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(458);
          match(Python3Parser::COMMA);
          setState(464);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == Python3Parser::POWER) {
            setState(459);
            match(Python3Parser::POWER);
            setState(460);
            vfpdef();
            setState(462);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == Python3Parser::COMMA) {
              setState(461);
              match(Python3Parser::COMMA);
            }
          }
        }
        break;
      }

      case Python3Parser::POWER: {
        setState(468);
        match(Python3Parser::POWER);
        setState(469);
        vfpdef();
        setState(471);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(470);
          match(Python3Parser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VfpdefContext ------------------------------------------------------------------

Python3Parser::VfpdefContext::VfpdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::NameContext* Python3Parser::VfpdefContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::VfpdefContext::getRuleIndex() const {
  return Python3Parser::RuleVfpdef;
}

void Python3Parser::VfpdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVfpdef(this);
}

void Python3Parser::VfpdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVfpdef(this);
}


std::any Python3Parser::VfpdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitVfpdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::VfpdefContext* Python3Parser::vfpdef() {
  VfpdefContext *_localctx = _tracker.createInstance<VfpdefContext>(_ctx, getState());
  enterRule(_localctx, 24, Python3Parser::RuleVfpdef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(475);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

Python3Parser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Simple_stmtsContext* Python3Parser::StmtContext::simple_stmts() {
  return getRuleContext<Python3Parser::Simple_stmtsContext>(0);
}

Python3Parser::Compound_stmtContext* Python3Parser::StmtContext::compound_stmt() {
  return getRuleContext<Python3Parser::Compound_stmtContext>(0);
}


size_t Python3Parser::StmtContext::getRuleIndex() const {
  return Python3Parser::RuleStmt;
}

void Python3Parser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void Python3Parser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}


std::any Python3Parser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::StmtContext* Python3Parser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 26, Python3Parser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(479);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(477);
      simple_stmts();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(478);
      compound_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_stmtsContext ------------------------------------------------------------------

Python3Parser::Simple_stmtsContext::Simple_stmtsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Simple_stmtContext *> Python3Parser::Simple_stmtsContext::simple_stmt() {
  return getRuleContexts<Python3Parser::Simple_stmtContext>();
}

Python3Parser::Simple_stmtContext* Python3Parser::Simple_stmtsContext::simple_stmt(size_t i) {
  return getRuleContext<Python3Parser::Simple_stmtContext>(i);
}

tree::TerminalNode* Python3Parser::Simple_stmtsContext::NEWLINE() {
  return getToken(Python3Parser::NEWLINE, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::Simple_stmtsContext::SEMI_COLON() {
  return getTokens(Python3Parser::SEMI_COLON);
}

tree::TerminalNode* Python3Parser::Simple_stmtsContext::SEMI_COLON(size_t i) {
  return getToken(Python3Parser::SEMI_COLON, i);
}


size_t Python3Parser::Simple_stmtsContext::getRuleIndex() const {
  return Python3Parser::RuleSimple_stmts;
}

void Python3Parser::Simple_stmtsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_stmts(this);
}

void Python3Parser::Simple_stmtsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_stmts(this);
}


std::any Python3Parser::Simple_stmtsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSimple_stmts(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Simple_stmtsContext* Python3Parser::simple_stmts() {
  Simple_stmtsContext *_localctx = _tracker.createInstance<Simple_stmtsContext>(_ctx, getState());
  enterRule(_localctx, 28, Python3Parser::RuleSimple_stmts);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(481);
    simple_stmt();
    setState(486);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(482);
        match(Python3Parser::SEMI_COLON);
        setState(483);
        simple_stmt(); 
      }
      setState(488);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
    setState(490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::SEMI_COLON) {
      setState(489);
      match(Python3Parser::SEMI_COLON);
    }
    setState(492);
    match(Python3Parser::NEWLINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_stmtContext ------------------------------------------------------------------

Python3Parser::Simple_stmtContext::Simple_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Expr_stmtContext* Python3Parser::Simple_stmtContext::expr_stmt() {
  return getRuleContext<Python3Parser::Expr_stmtContext>(0);
}

Python3Parser::Del_stmtContext* Python3Parser::Simple_stmtContext::del_stmt() {
  return getRuleContext<Python3Parser::Del_stmtContext>(0);
}

Python3Parser::Pass_stmtContext* Python3Parser::Simple_stmtContext::pass_stmt() {
  return getRuleContext<Python3Parser::Pass_stmtContext>(0);
}

Python3Parser::Flow_stmtContext* Python3Parser::Simple_stmtContext::flow_stmt() {
  return getRuleContext<Python3Parser::Flow_stmtContext>(0);
}

Python3Parser::Import_stmtContext* Python3Parser::Simple_stmtContext::import_stmt() {
  return getRuleContext<Python3Parser::Import_stmtContext>(0);
}

Python3Parser::Global_stmtContext* Python3Parser::Simple_stmtContext::global_stmt() {
  return getRuleContext<Python3Parser::Global_stmtContext>(0);
}

Python3Parser::Nonlocal_stmtContext* Python3Parser::Simple_stmtContext::nonlocal_stmt() {
  return getRuleContext<Python3Parser::Nonlocal_stmtContext>(0);
}

Python3Parser::Assert_stmtContext* Python3Parser::Simple_stmtContext::assert_stmt() {
  return getRuleContext<Python3Parser::Assert_stmtContext>(0);
}


size_t Python3Parser::Simple_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleSimple_stmt;
}

void Python3Parser::Simple_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_stmt(this);
}

void Python3Parser::Simple_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_stmt(this);
}


std::any Python3Parser::Simple_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSimple_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Simple_stmtContext* Python3Parser::simple_stmt() {
  Simple_stmtContext *_localctx = _tracker.createInstance<Simple_stmtContext>(_ctx, getState());
  enterRule(_localctx, 30, Python3Parser::RuleSimple_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(502);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::STAR:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        setState(494);
        expr_stmt();
        break;
      }

      case Python3Parser::DEL: {
        setState(495);
        del_stmt();
        break;
      }

      case Python3Parser::PASS: {
        setState(496);
        pass_stmt();
        break;
      }

      case Python3Parser::BREAK:
      case Python3Parser::CONTINUE:
      case Python3Parser::RAISE:
      case Python3Parser::RETURN:
      case Python3Parser::YIELD: {
        setState(497);
        flow_stmt();
        break;
      }

      case Python3Parser::FROM:
      case Python3Parser::IMPORT: {
        setState(498);
        import_stmt();
        break;
      }

      case Python3Parser::GLOBAL: {
        setState(499);
        global_stmt();
        break;
      }

      case Python3Parser::NONLOCAL: {
        setState(500);
        nonlocal_stmt();
        break;
      }

      case Python3Parser::ASSERT: {
        setState(501);
        assert_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_stmtContext ------------------------------------------------------------------

Python3Parser::Expr_stmtContext::Expr_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Testlist_star_exprContext *> Python3Parser::Expr_stmtContext::testlist_star_expr() {
  return getRuleContexts<Python3Parser::Testlist_star_exprContext>();
}

Python3Parser::Testlist_star_exprContext* Python3Parser::Expr_stmtContext::testlist_star_expr(size_t i) {
  return getRuleContext<Python3Parser::Testlist_star_exprContext>(i);
}

Python3Parser::AnnassignContext* Python3Parser::Expr_stmtContext::annassign() {
  return getRuleContext<Python3Parser::AnnassignContext>(0);
}

Python3Parser::AugassignContext* Python3Parser::Expr_stmtContext::augassign() {
  return getRuleContext<Python3Parser::AugassignContext>(0);
}

std::vector<Python3Parser::Yield_exprContext *> Python3Parser::Expr_stmtContext::yield_expr() {
  return getRuleContexts<Python3Parser::Yield_exprContext>();
}

Python3Parser::Yield_exprContext* Python3Parser::Expr_stmtContext::yield_expr(size_t i) {
  return getRuleContext<Python3Parser::Yield_exprContext>(i);
}

Python3Parser::TestlistContext* Python3Parser::Expr_stmtContext::testlist() {
  return getRuleContext<Python3Parser::TestlistContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::Expr_stmtContext::ASSIGN() {
  return getTokens(Python3Parser::ASSIGN);
}

tree::TerminalNode* Python3Parser::Expr_stmtContext::ASSIGN(size_t i) {
  return getToken(Python3Parser::ASSIGN, i);
}


size_t Python3Parser::Expr_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleExpr_stmt;
}

void Python3Parser::Expr_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_stmt(this);
}

void Python3Parser::Expr_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_stmt(this);
}


std::any Python3Parser::Expr_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitExpr_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Expr_stmtContext* Python3Parser::expr_stmt() {
  Expr_stmtContext *_localctx = _tracker.createInstance<Expr_stmtContext>(_ctx, getState());
  enterRule(_localctx, 32, Python3Parser::RuleExpr_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(504);
    testlist_star_expr();
    setState(521);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::COLON: {
        setState(505);
        annassign();
        break;
      }

      case Python3Parser::ADD_ASSIGN:
      case Python3Parser::SUB_ASSIGN:
      case Python3Parser::MULT_ASSIGN:
      case Python3Parser::AT_ASSIGN:
      case Python3Parser::DIV_ASSIGN:
      case Python3Parser::MOD_ASSIGN:
      case Python3Parser::AND_ASSIGN:
      case Python3Parser::OR_ASSIGN:
      case Python3Parser::XOR_ASSIGN:
      case Python3Parser::LEFT_SHIFT_ASSIGN:
      case Python3Parser::RIGHT_SHIFT_ASSIGN:
      case Python3Parser::POWER_ASSIGN:
      case Python3Parser::IDIV_ASSIGN: {
        setState(506);
        augassign();
        setState(509);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case Python3Parser::YIELD: {
            setState(507);
            yield_expr();
            break;
          }

          case Python3Parser::STRING:
          case Python3Parser::NUMBER:
          case Python3Parser::AWAIT:
          case Python3Parser::FALSE:
          case Python3Parser::LAMBDA:
          case Python3Parser::MATCH:
          case Python3Parser::NONE:
          case Python3Parser::NOT:
          case Python3Parser::TRUE:
          case Python3Parser::UNDERSCORE:
          case Python3Parser::NAME:
          case Python3Parser::ELLIPSIS:
          case Python3Parser::OPEN_PAREN:
          case Python3Parser::OPEN_BRACK:
          case Python3Parser::ADD:
          case Python3Parser::MINUS:
          case Python3Parser::NOT_OP:
          case Python3Parser::OPEN_BRACE: {
            setState(508);
            testlist();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case Python3Parser::NEWLINE:
      case Python3Parser::SEMI_COLON:
      case Python3Parser::ASSIGN: {
        setState(518);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == Python3Parser::ASSIGN) {
          setState(511);
          match(Python3Parser::ASSIGN);
          setState(514);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case Python3Parser::YIELD: {
              setState(512);
              yield_expr();
              break;
            }

            case Python3Parser::STRING:
            case Python3Parser::NUMBER:
            case Python3Parser::AWAIT:
            case Python3Parser::FALSE:
            case Python3Parser::LAMBDA:
            case Python3Parser::MATCH:
            case Python3Parser::NONE:
            case Python3Parser::NOT:
            case Python3Parser::TRUE:
            case Python3Parser::UNDERSCORE:
            case Python3Parser::NAME:
            case Python3Parser::ELLIPSIS:
            case Python3Parser::STAR:
            case Python3Parser::OPEN_PAREN:
            case Python3Parser::OPEN_BRACK:
            case Python3Parser::ADD:
            case Python3Parser::MINUS:
            case Python3Parser::NOT_OP:
            case Python3Parser::OPEN_BRACE: {
              setState(513);
              testlist_star_expr();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(520);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnnassignContext ------------------------------------------------------------------

Python3Parser::AnnassignContext::AnnassignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::AnnassignContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

std::vector<Python3Parser::TestContext *> Python3Parser::AnnassignContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::AnnassignContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

tree::TerminalNode* Python3Parser::AnnassignContext::ASSIGN() {
  return getToken(Python3Parser::ASSIGN, 0);
}


size_t Python3Parser::AnnassignContext::getRuleIndex() const {
  return Python3Parser::RuleAnnassign;
}

void Python3Parser::AnnassignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnnassign(this);
}

void Python3Parser::AnnassignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnnassign(this);
}


std::any Python3Parser::AnnassignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAnnassign(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::AnnassignContext* Python3Parser::annassign() {
  AnnassignContext *_localctx = _tracker.createInstance<AnnassignContext>(_ctx, getState());
  enterRule(_localctx, 34, Python3Parser::RuleAnnassign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(523);
    match(Python3Parser::COLON);
    setState(524);
    test();
    setState(527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ASSIGN) {
      setState(525);
      match(Python3Parser::ASSIGN);
      setState(526);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Testlist_star_exprContext ------------------------------------------------------------------

Python3Parser::Testlist_star_exprContext::Testlist_star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::Testlist_star_exprContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::Testlist_star_exprContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<Python3Parser::Star_exprContext *> Python3Parser::Testlist_star_exprContext::star_expr() {
  return getRuleContexts<Python3Parser::Star_exprContext>();
}

Python3Parser::Star_exprContext* Python3Parser::Testlist_star_exprContext::star_expr(size_t i) {
  return getRuleContext<Python3Parser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Testlist_star_exprContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Testlist_star_exprContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Testlist_star_exprContext::getRuleIndex() const {
  return Python3Parser::RuleTestlist_star_expr;
}

void Python3Parser::Testlist_star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist_star_expr(this);
}

void Python3Parser::Testlist_star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist_star_expr(this);
}


std::any Python3Parser::Testlist_star_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTestlist_star_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Testlist_star_exprContext* Python3Parser::testlist_star_expr() {
  Testlist_star_exprContext *_localctx = _tracker.createInstance<Testlist_star_exprContext>(_ctx, getState());
  enterRule(_localctx, 36, Python3Parser::RuleTestlist_star_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(531);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        setState(529);
        test();
        break;
      }

      case Python3Parser::STAR: {
        setState(530);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(540);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(533);
        match(Python3Parser::COMMA);
        setState(536);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case Python3Parser::STRING:
          case Python3Parser::NUMBER:
          case Python3Parser::AWAIT:
          case Python3Parser::FALSE:
          case Python3Parser::LAMBDA:
          case Python3Parser::MATCH:
          case Python3Parser::NONE:
          case Python3Parser::NOT:
          case Python3Parser::TRUE:
          case Python3Parser::UNDERSCORE:
          case Python3Parser::NAME:
          case Python3Parser::ELLIPSIS:
          case Python3Parser::OPEN_PAREN:
          case Python3Parser::OPEN_BRACK:
          case Python3Parser::ADD:
          case Python3Parser::MINUS:
          case Python3Parser::NOT_OP:
          case Python3Parser::OPEN_BRACE: {
            setState(534);
            test();
            break;
          }

          case Python3Parser::STAR: {
            setState(535);
            star_expr();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(542);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx);
    }
    setState(544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(543);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AugassignContext ------------------------------------------------------------------

Python3Parser::AugassignContext::AugassignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::AugassignContext::ADD_ASSIGN() {
  return getToken(Python3Parser::ADD_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::SUB_ASSIGN() {
  return getToken(Python3Parser::SUB_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::MULT_ASSIGN() {
  return getToken(Python3Parser::MULT_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::AT_ASSIGN() {
  return getToken(Python3Parser::AT_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::DIV_ASSIGN() {
  return getToken(Python3Parser::DIV_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::MOD_ASSIGN() {
  return getToken(Python3Parser::MOD_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::AND_ASSIGN() {
  return getToken(Python3Parser::AND_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::OR_ASSIGN() {
  return getToken(Python3Parser::OR_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::XOR_ASSIGN() {
  return getToken(Python3Parser::XOR_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::LEFT_SHIFT_ASSIGN() {
  return getToken(Python3Parser::LEFT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::RIGHT_SHIFT_ASSIGN() {
  return getToken(Python3Parser::RIGHT_SHIFT_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::POWER_ASSIGN() {
  return getToken(Python3Parser::POWER_ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::AugassignContext::IDIV_ASSIGN() {
  return getToken(Python3Parser::IDIV_ASSIGN, 0);
}


size_t Python3Parser::AugassignContext::getRuleIndex() const {
  return Python3Parser::RuleAugassign;
}

void Python3Parser::AugassignContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAugassign(this);
}

void Python3Parser::AugassignContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAugassign(this);
}


std::any Python3Parser::AugassignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAugassign(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::AugassignContext* Python3Parser::augassign() {
  AugassignContext *_localctx = _tracker.createInstance<AugassignContext>(_ctx, getState());
  enterRule(_localctx, 38, Python3Parser::RuleAugassign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(546);
    _la = _input->LA(1);
    if (!(((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 8191) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Del_stmtContext ------------------------------------------------------------------

Python3Parser::Del_stmtContext::Del_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Del_stmtContext::DEL() {
  return getToken(Python3Parser::DEL, 0);
}

Python3Parser::ExprlistContext* Python3Parser::Del_stmtContext::exprlist() {
  return getRuleContext<Python3Parser::ExprlistContext>(0);
}


size_t Python3Parser::Del_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleDel_stmt;
}

void Python3Parser::Del_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDel_stmt(this);
}

void Python3Parser::Del_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDel_stmt(this);
}


std::any Python3Parser::Del_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDel_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Del_stmtContext* Python3Parser::del_stmt() {
  Del_stmtContext *_localctx = _tracker.createInstance<Del_stmtContext>(_ctx, getState());
  enterRule(_localctx, 40, Python3Parser::RuleDel_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    match(Python3Parser::DEL);
    setState(549);
    exprlist();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_stmtContext ------------------------------------------------------------------

Python3Parser::Pass_stmtContext::Pass_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Pass_stmtContext::PASS() {
  return getToken(Python3Parser::PASS, 0);
}


size_t Python3Parser::Pass_stmtContext::getRuleIndex() const {
  return Python3Parser::RulePass_stmt;
}

void Python3Parser::Pass_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPass_stmt(this);
}

void Python3Parser::Pass_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPass_stmt(this);
}


std::any Python3Parser::Pass_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitPass_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Pass_stmtContext* Python3Parser::pass_stmt() {
  Pass_stmtContext *_localctx = _tracker.createInstance<Pass_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, Python3Parser::RulePass_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(551);
    match(Python3Parser::PASS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Flow_stmtContext ------------------------------------------------------------------

Python3Parser::Flow_stmtContext::Flow_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Break_stmtContext* Python3Parser::Flow_stmtContext::break_stmt() {
  return getRuleContext<Python3Parser::Break_stmtContext>(0);
}

Python3Parser::Continue_stmtContext* Python3Parser::Flow_stmtContext::continue_stmt() {
  return getRuleContext<Python3Parser::Continue_stmtContext>(0);
}

Python3Parser::Return_stmtContext* Python3Parser::Flow_stmtContext::return_stmt() {
  return getRuleContext<Python3Parser::Return_stmtContext>(0);
}

Python3Parser::Raise_stmtContext* Python3Parser::Flow_stmtContext::raise_stmt() {
  return getRuleContext<Python3Parser::Raise_stmtContext>(0);
}

Python3Parser::Yield_stmtContext* Python3Parser::Flow_stmtContext::yield_stmt() {
  return getRuleContext<Python3Parser::Yield_stmtContext>(0);
}


size_t Python3Parser::Flow_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleFlow_stmt;
}

void Python3Parser::Flow_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlow_stmt(this);
}

void Python3Parser::Flow_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlow_stmt(this);
}


std::any Python3Parser::Flow_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitFlow_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Flow_stmtContext* Python3Parser::flow_stmt() {
  Flow_stmtContext *_localctx = _tracker.createInstance<Flow_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, Python3Parser::RuleFlow_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(558);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::BREAK: {
        enterOuterAlt(_localctx, 1);
        setState(553);
        break_stmt();
        break;
      }

      case Python3Parser::CONTINUE: {
        enterOuterAlt(_localctx, 2);
        setState(554);
        continue_stmt();
        break;
      }

      case Python3Parser::RETURN: {
        enterOuterAlt(_localctx, 3);
        setState(555);
        return_stmt();
        break;
      }

      case Python3Parser::RAISE: {
        enterOuterAlt(_localctx, 4);
        setState(556);
        raise_stmt();
        break;
      }

      case Python3Parser::YIELD: {
        enterOuterAlt(_localctx, 5);
        setState(557);
        yield_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Break_stmtContext ------------------------------------------------------------------

Python3Parser::Break_stmtContext::Break_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Break_stmtContext::BREAK() {
  return getToken(Python3Parser::BREAK, 0);
}


size_t Python3Parser::Break_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleBreak_stmt;
}

void Python3Parser::Break_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBreak_stmt(this);
}

void Python3Parser::Break_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBreak_stmt(this);
}


std::any Python3Parser::Break_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitBreak_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Break_stmtContext* Python3Parser::break_stmt() {
  Break_stmtContext *_localctx = _tracker.createInstance<Break_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, Python3Parser::RuleBreak_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(560);
    match(Python3Parser::BREAK);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continue_stmtContext ------------------------------------------------------------------

Python3Parser::Continue_stmtContext::Continue_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Continue_stmtContext::CONTINUE() {
  return getToken(Python3Parser::CONTINUE, 0);
}


size_t Python3Parser::Continue_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleContinue_stmt;
}

void Python3Parser::Continue_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContinue_stmt(this);
}

void Python3Parser::Continue_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContinue_stmt(this);
}


std::any Python3Parser::Continue_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitContinue_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Continue_stmtContext* Python3Parser::continue_stmt() {
  Continue_stmtContext *_localctx = _tracker.createInstance<Continue_stmtContext>(_ctx, getState());
  enterRule(_localctx, 48, Python3Parser::RuleContinue_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(562);
    match(Python3Parser::CONTINUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_stmtContext ------------------------------------------------------------------

Python3Parser::Return_stmtContext::Return_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Return_stmtContext::RETURN() {
  return getToken(Python3Parser::RETURN, 0);
}

Python3Parser::TestlistContext* Python3Parser::Return_stmtContext::testlist() {
  return getRuleContext<Python3Parser::TestlistContext>(0);
}


size_t Python3Parser::Return_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleReturn_stmt;
}

void Python3Parser::Return_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn_stmt(this);
}

void Python3Parser::Return_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn_stmt(this);
}


std::any Python3Parser::Return_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitReturn_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Return_stmtContext* Python3Parser::return_stmt() {
  Return_stmtContext *_localctx = _tracker.createInstance<Return_stmtContext>(_ctx, getState());
  enterRule(_localctx, 50, Python3Parser::RuleReturn_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(564);
    match(Python3Parser::RETURN);
    setState(566);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0)) {
      setState(565);
      testlist();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_stmtContext ------------------------------------------------------------------

Python3Parser::Yield_stmtContext::Yield_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Yield_exprContext* Python3Parser::Yield_stmtContext::yield_expr() {
  return getRuleContext<Python3Parser::Yield_exprContext>(0);
}


size_t Python3Parser::Yield_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleYield_stmt;
}

void Python3Parser::Yield_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_stmt(this);
}

void Python3Parser::Yield_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_stmt(this);
}


std::any Python3Parser::Yield_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitYield_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Yield_stmtContext* Python3Parser::yield_stmt() {
  Yield_stmtContext *_localctx = _tracker.createInstance<Yield_stmtContext>(_ctx, getState());
  enterRule(_localctx, 52, Python3Parser::RuleYield_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    yield_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Raise_stmtContext ------------------------------------------------------------------

Python3Parser::Raise_stmtContext::Raise_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Raise_stmtContext::RAISE() {
  return getToken(Python3Parser::RAISE, 0);
}

std::vector<Python3Parser::TestContext *> Python3Parser::Raise_stmtContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::Raise_stmtContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

tree::TerminalNode* Python3Parser::Raise_stmtContext::FROM() {
  return getToken(Python3Parser::FROM, 0);
}


size_t Python3Parser::Raise_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleRaise_stmt;
}

void Python3Parser::Raise_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_stmt(this);
}

void Python3Parser::Raise_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_stmt(this);
}


std::any Python3Parser::Raise_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitRaise_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Raise_stmtContext* Python3Parser::raise_stmt() {
  Raise_stmtContext *_localctx = _tracker.createInstance<Raise_stmtContext>(_ctx, getState());
  enterRule(_localctx, 54, Python3Parser::RuleRaise_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    match(Python3Parser::RAISE);
    setState(576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0)) {
      setState(571);
      test();
      setState(574);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::FROM) {
        setState(572);
        match(Python3Parser::FROM);
        setState(573);
        test();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_stmtContext ------------------------------------------------------------------

Python3Parser::Import_stmtContext::Import_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Import_nameContext* Python3Parser::Import_stmtContext::import_name() {
  return getRuleContext<Python3Parser::Import_nameContext>(0);
}

Python3Parser::Import_fromContext* Python3Parser::Import_stmtContext::import_from() {
  return getRuleContext<Python3Parser::Import_fromContext>(0);
}


size_t Python3Parser::Import_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleImport_stmt;
}

void Python3Parser::Import_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_stmt(this);
}

void Python3Parser::Import_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_stmt(this);
}


std::any Python3Parser::Import_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImport_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Import_stmtContext* Python3Parser::import_stmt() {
  Import_stmtContext *_localctx = _tracker.createInstance<Import_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, Python3Parser::RuleImport_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(580);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::IMPORT: {
        enterOuterAlt(_localctx, 1);
        setState(578);
        import_name();
        break;
      }

      case Python3Parser::FROM: {
        enterOuterAlt(_localctx, 2);
        setState(579);
        import_from();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_nameContext ------------------------------------------------------------------

Python3Parser::Import_nameContext::Import_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Import_nameContext::IMPORT() {
  return getToken(Python3Parser::IMPORT, 0);
}

Python3Parser::Dotted_as_namesContext* Python3Parser::Import_nameContext::dotted_as_names() {
  return getRuleContext<Python3Parser::Dotted_as_namesContext>(0);
}


size_t Python3Parser::Import_nameContext::getRuleIndex() const {
  return Python3Parser::RuleImport_name;
}

void Python3Parser::Import_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_name(this);
}

void Python3Parser::Import_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_name(this);
}


std::any Python3Parser::Import_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImport_name(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Import_nameContext* Python3Parser::import_name() {
  Import_nameContext *_localctx = _tracker.createInstance<Import_nameContext>(_ctx, getState());
  enterRule(_localctx, 58, Python3Parser::RuleImport_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(582);
    match(Python3Parser::IMPORT);
    setState(583);
    dotted_as_names();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_fromContext ------------------------------------------------------------------

Python3Parser::Import_fromContext::Import_fromContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Import_fromContext::FROM() {
  return getToken(Python3Parser::FROM, 0);
}

tree::TerminalNode* Python3Parser::Import_fromContext::IMPORT() {
  return getToken(Python3Parser::IMPORT, 0);
}

Python3Parser::Dotted_nameContext* Python3Parser::Import_fromContext::dotted_name() {
  return getRuleContext<Python3Parser::Dotted_nameContext>(0);
}

tree::TerminalNode* Python3Parser::Import_fromContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

tree::TerminalNode* Python3Parser::Import_fromContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

Python3Parser::Import_as_namesContext* Python3Parser::Import_fromContext::import_as_names() {
  return getRuleContext<Python3Parser::Import_as_namesContext>(0);
}

tree::TerminalNode* Python3Parser::Import_fromContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::Import_fromContext::DOT() {
  return getTokens(Python3Parser::DOT);
}

tree::TerminalNode* Python3Parser::Import_fromContext::DOT(size_t i) {
  return getToken(Python3Parser::DOT, i);
}

std::vector<tree::TerminalNode *> Python3Parser::Import_fromContext::ELLIPSIS() {
  return getTokens(Python3Parser::ELLIPSIS);
}

tree::TerminalNode* Python3Parser::Import_fromContext::ELLIPSIS(size_t i) {
  return getToken(Python3Parser::ELLIPSIS, i);
}


size_t Python3Parser::Import_fromContext::getRuleIndex() const {
  return Python3Parser::RuleImport_from;
}

void Python3Parser::Import_fromContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_from(this);
}

void Python3Parser::Import_fromContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_from(this);
}


std::any Python3Parser::Import_fromContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImport_from(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Import_fromContext* Python3Parser::import_from() {
  Import_fromContext *_localctx = _tracker.createInstance<Import_fromContext>(_ctx, getState());
  enterRule(_localctx, 60, Python3Parser::RuleImport_from);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    match(Python3Parser::FROM);
    setState(598);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(589);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == Python3Parser::DOT

      || _la == Python3Parser::ELLIPSIS) {
        setState(586);
        _la = _input->LA(1);
        if (!(_la == Python3Parser::DOT

        || _la == Python3Parser::ELLIPSIS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(591);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(592);
      dotted_name();
      break;
    }

    case 2: {
      setState(594); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(593);
        _la = _input->LA(1);
        if (!(_la == Python3Parser::DOT

        || _la == Python3Parser::ELLIPSIS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(596); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == Python3Parser::DOT

      || _la == Python3Parser::ELLIPSIS);
      break;
    }

    default:
      break;
    }
    setState(600);
    match(Python3Parser::IMPORT);
    setState(607);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STAR: {
        setState(601);
        match(Python3Parser::STAR);
        break;
      }

      case Python3Parser::OPEN_PAREN: {
        setState(602);
        match(Python3Parser::OPEN_PAREN);
        setState(603);
        import_as_names();
        setState(604);
        match(Python3Parser::CLOSE_PAREN);
        break;
      }

      case Python3Parser::MATCH:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME: {
        setState(606);
        import_as_names();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_nameContext ------------------------------------------------------------------

Python3Parser::Import_as_nameContext::Import_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::NameContext *> Python3Parser::Import_as_nameContext::name() {
  return getRuleContexts<Python3Parser::NameContext>();
}

Python3Parser::NameContext* Python3Parser::Import_as_nameContext::name(size_t i) {
  return getRuleContext<Python3Parser::NameContext>(i);
}

tree::TerminalNode* Python3Parser::Import_as_nameContext::AS() {
  return getToken(Python3Parser::AS, 0);
}


size_t Python3Parser::Import_as_nameContext::getRuleIndex() const {
  return Python3Parser::RuleImport_as_name;
}

void Python3Parser::Import_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_name(this);
}

void Python3Parser::Import_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_name(this);
}


std::any Python3Parser::Import_as_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImport_as_name(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Import_as_nameContext* Python3Parser::import_as_name() {
  Import_as_nameContext *_localctx = _tracker.createInstance<Import_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 62, Python3Parser::RuleImport_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(609);
    name();
    setState(612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::AS) {
      setState(610);
      match(Python3Parser::AS);
      setState(611);
      name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_as_nameContext ------------------------------------------------------------------

Python3Parser::Dotted_as_nameContext::Dotted_as_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Dotted_nameContext* Python3Parser::Dotted_as_nameContext::dotted_name() {
  return getRuleContext<Python3Parser::Dotted_nameContext>(0);
}

tree::TerminalNode* Python3Parser::Dotted_as_nameContext::AS() {
  return getToken(Python3Parser::AS, 0);
}

Python3Parser::NameContext* Python3Parser::Dotted_as_nameContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::Dotted_as_nameContext::getRuleIndex() const {
  return Python3Parser::RuleDotted_as_name;
}

void Python3Parser::Dotted_as_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_as_name(this);
}

void Python3Parser::Dotted_as_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_as_name(this);
}


std::any Python3Parser::Dotted_as_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDotted_as_name(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Dotted_as_nameContext* Python3Parser::dotted_as_name() {
  Dotted_as_nameContext *_localctx = _tracker.createInstance<Dotted_as_nameContext>(_ctx, getState());
  enterRule(_localctx, 64, Python3Parser::RuleDotted_as_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    dotted_name();
    setState(617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::AS) {
      setState(615);
      match(Python3Parser::AS);
      setState(616);
      name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_as_namesContext ------------------------------------------------------------------

Python3Parser::Import_as_namesContext::Import_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Import_as_nameContext *> Python3Parser::Import_as_namesContext::import_as_name() {
  return getRuleContexts<Python3Parser::Import_as_nameContext>();
}

Python3Parser::Import_as_nameContext* Python3Parser::Import_as_namesContext::import_as_name(size_t i) {
  return getRuleContext<Python3Parser::Import_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Import_as_namesContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Import_as_namesContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Import_as_namesContext::getRuleIndex() const {
  return Python3Parser::RuleImport_as_names;
}

void Python3Parser::Import_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_as_names(this);
}

void Python3Parser::Import_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_as_names(this);
}


std::any Python3Parser::Import_as_namesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImport_as_names(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Import_as_namesContext* Python3Parser::import_as_names() {
  Import_as_namesContext *_localctx = _tracker.createInstance<Import_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 66, Python3Parser::RuleImport_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(619);
    import_as_name();
    setState(624);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(620);
        match(Python3Parser::COMMA);
        setState(621);
        import_as_name(); 
      }
      setState(626);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
    setState(628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(627);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_as_namesContext ------------------------------------------------------------------

Python3Parser::Dotted_as_namesContext::Dotted_as_namesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Dotted_as_nameContext *> Python3Parser::Dotted_as_namesContext::dotted_as_name() {
  return getRuleContexts<Python3Parser::Dotted_as_nameContext>();
}

Python3Parser::Dotted_as_nameContext* Python3Parser::Dotted_as_namesContext::dotted_as_name(size_t i) {
  return getRuleContext<Python3Parser::Dotted_as_nameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Dotted_as_namesContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Dotted_as_namesContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Dotted_as_namesContext::getRuleIndex() const {
  return Python3Parser::RuleDotted_as_names;
}

void Python3Parser::Dotted_as_namesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_as_names(this);
}

void Python3Parser::Dotted_as_namesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_as_names(this);
}


std::any Python3Parser::Dotted_as_namesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDotted_as_names(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Dotted_as_namesContext* Python3Parser::dotted_as_names() {
  Dotted_as_namesContext *_localctx = _tracker.createInstance<Dotted_as_namesContext>(_ctx, getState());
  enterRule(_localctx, 68, Python3Parser::RuleDotted_as_names);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(630);
    dotted_as_name();
    setState(635);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::COMMA) {
      setState(631);
      match(Python3Parser::COMMA);
      setState(632);
      dotted_as_name();
      setState(637);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dotted_nameContext ------------------------------------------------------------------

Python3Parser::Dotted_nameContext::Dotted_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::NameContext *> Python3Parser::Dotted_nameContext::name() {
  return getRuleContexts<Python3Parser::NameContext>();
}

Python3Parser::NameContext* Python3Parser::Dotted_nameContext::name(size_t i) {
  return getRuleContext<Python3Parser::NameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Dotted_nameContext::DOT() {
  return getTokens(Python3Parser::DOT);
}

tree::TerminalNode* Python3Parser::Dotted_nameContext::DOT(size_t i) {
  return getToken(Python3Parser::DOT, i);
}


size_t Python3Parser::Dotted_nameContext::getRuleIndex() const {
  return Python3Parser::RuleDotted_name;
}

void Python3Parser::Dotted_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotted_name(this);
}

void Python3Parser::Dotted_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotted_name(this);
}


std::any Python3Parser::Dotted_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDotted_name(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Dotted_nameContext* Python3Parser::dotted_name() {
  Dotted_nameContext *_localctx = _tracker.createInstance<Dotted_nameContext>(_ctx, getState());
  enterRule(_localctx, 70, Python3Parser::RuleDotted_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(638);
    name();
    setState(643);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::DOT) {
      setState(639);
      match(Python3Parser::DOT);
      setState(640);
      name();
      setState(645);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_stmtContext ------------------------------------------------------------------

Python3Parser::Global_stmtContext::Global_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Global_stmtContext::GLOBAL() {
  return getToken(Python3Parser::GLOBAL, 0);
}

std::vector<Python3Parser::NameContext *> Python3Parser::Global_stmtContext::name() {
  return getRuleContexts<Python3Parser::NameContext>();
}

Python3Parser::NameContext* Python3Parser::Global_stmtContext::name(size_t i) {
  return getRuleContext<Python3Parser::NameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Global_stmtContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Global_stmtContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Global_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleGlobal_stmt;
}

void Python3Parser::Global_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_stmt(this);
}

void Python3Parser::Global_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_stmt(this);
}


std::any Python3Parser::Global_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitGlobal_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Global_stmtContext* Python3Parser::global_stmt() {
  Global_stmtContext *_localctx = _tracker.createInstance<Global_stmtContext>(_ctx, getState());
  enterRule(_localctx, 72, Python3Parser::RuleGlobal_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(646);
    match(Python3Parser::GLOBAL);
    setState(647);
    name();
    setState(652);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::COMMA) {
      setState(648);
      match(Python3Parser::COMMA);
      setState(649);
      name();
      setState(654);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonlocal_stmtContext ------------------------------------------------------------------

Python3Parser::Nonlocal_stmtContext::Nonlocal_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Nonlocal_stmtContext::NONLOCAL() {
  return getToken(Python3Parser::NONLOCAL, 0);
}

std::vector<Python3Parser::NameContext *> Python3Parser::Nonlocal_stmtContext::name() {
  return getRuleContexts<Python3Parser::NameContext>();
}

Python3Parser::NameContext* Python3Parser::Nonlocal_stmtContext::name(size_t i) {
  return getRuleContext<Python3Parser::NameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Nonlocal_stmtContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Nonlocal_stmtContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Nonlocal_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleNonlocal_stmt;
}

void Python3Parser::Nonlocal_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonlocal_stmt(this);
}

void Python3Parser::Nonlocal_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonlocal_stmt(this);
}


std::any Python3Parser::Nonlocal_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitNonlocal_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Nonlocal_stmtContext* Python3Parser::nonlocal_stmt() {
  Nonlocal_stmtContext *_localctx = _tracker.createInstance<Nonlocal_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, Python3Parser::RuleNonlocal_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    match(Python3Parser::NONLOCAL);
    setState(656);
    name();
    setState(661);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::COMMA) {
      setState(657);
      match(Python3Parser::COMMA);
      setState(658);
      name();
      setState(663);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assert_stmtContext ------------------------------------------------------------------

Python3Parser::Assert_stmtContext::Assert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Assert_stmtContext::ASSERT() {
  return getToken(Python3Parser::ASSERT, 0);
}

std::vector<Python3Parser::TestContext *> Python3Parser::Assert_stmtContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::Assert_stmtContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

tree::TerminalNode* Python3Parser::Assert_stmtContext::COMMA() {
  return getToken(Python3Parser::COMMA, 0);
}


size_t Python3Parser::Assert_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleAssert_stmt;
}

void Python3Parser::Assert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssert_stmt(this);
}

void Python3Parser::Assert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssert_stmt(this);
}


std::any Python3Parser::Assert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAssert_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Assert_stmtContext* Python3Parser::assert_stmt() {
  Assert_stmtContext *_localctx = _tracker.createInstance<Assert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 76, Python3Parser::RuleAssert_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(664);
    match(Python3Parser::ASSERT);
    setState(665);
    test();
    setState(668);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(666);
      match(Python3Parser::COMMA);
      setState(667);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_stmtContext ------------------------------------------------------------------

Python3Parser::Compound_stmtContext::Compound_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::If_stmtContext* Python3Parser::Compound_stmtContext::if_stmt() {
  return getRuleContext<Python3Parser::If_stmtContext>(0);
}

Python3Parser::While_stmtContext* Python3Parser::Compound_stmtContext::while_stmt() {
  return getRuleContext<Python3Parser::While_stmtContext>(0);
}

Python3Parser::For_stmtContext* Python3Parser::Compound_stmtContext::for_stmt() {
  return getRuleContext<Python3Parser::For_stmtContext>(0);
}

Python3Parser::Try_stmtContext* Python3Parser::Compound_stmtContext::try_stmt() {
  return getRuleContext<Python3Parser::Try_stmtContext>(0);
}

Python3Parser::With_stmtContext* Python3Parser::Compound_stmtContext::with_stmt() {
  return getRuleContext<Python3Parser::With_stmtContext>(0);
}

Python3Parser::FuncdefContext* Python3Parser::Compound_stmtContext::funcdef() {
  return getRuleContext<Python3Parser::FuncdefContext>(0);
}

Python3Parser::ClassdefContext* Python3Parser::Compound_stmtContext::classdef() {
  return getRuleContext<Python3Parser::ClassdefContext>(0);
}

Python3Parser::DecoratedContext* Python3Parser::Compound_stmtContext::decorated() {
  return getRuleContext<Python3Parser::DecoratedContext>(0);
}

Python3Parser::Async_stmtContext* Python3Parser::Compound_stmtContext::async_stmt() {
  return getRuleContext<Python3Parser::Async_stmtContext>(0);
}

Python3Parser::Match_stmtContext* Python3Parser::Compound_stmtContext::match_stmt() {
  return getRuleContext<Python3Parser::Match_stmtContext>(0);
}


size_t Python3Parser::Compound_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleCompound_stmt;
}

void Python3Parser::Compound_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_stmt(this);
}

void Python3Parser::Compound_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_stmt(this);
}


std::any Python3Parser::Compound_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitCompound_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Compound_stmtContext* Python3Parser::compound_stmt() {
  Compound_stmtContext *_localctx = _tracker.createInstance<Compound_stmtContext>(_ctx, getState());
  enterRule(_localctx, 78, Python3Parser::RuleCompound_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(680);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(670);
        if_stmt();
        break;
      }

      case Python3Parser::WHILE: {
        enterOuterAlt(_localctx, 2);
        setState(671);
        while_stmt();
        break;
      }

      case Python3Parser::FOR: {
        enterOuterAlt(_localctx, 3);
        setState(672);
        for_stmt();
        break;
      }

      case Python3Parser::TRY: {
        enterOuterAlt(_localctx, 4);
        setState(673);
        try_stmt();
        break;
      }

      case Python3Parser::WITH: {
        enterOuterAlt(_localctx, 5);
        setState(674);
        with_stmt();
        break;
      }

      case Python3Parser::DEF: {
        enterOuterAlt(_localctx, 6);
        setState(675);
        funcdef();
        break;
      }

      case Python3Parser::CLASS: {
        enterOuterAlt(_localctx, 7);
        setState(676);
        classdef();
        break;
      }

      case Python3Parser::AT: {
        enterOuterAlt(_localctx, 8);
        setState(677);
        decorated();
        break;
      }

      case Python3Parser::ASYNC: {
        enterOuterAlt(_localctx, 9);
        setState(678);
        async_stmt();
        break;
      }

      case Python3Parser::MATCH: {
        enterOuterAlt(_localctx, 10);
        setState(679);
        match_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Async_stmtContext ------------------------------------------------------------------

Python3Parser::Async_stmtContext::Async_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Async_stmtContext::ASYNC() {
  return getToken(Python3Parser::ASYNC, 0);
}

Python3Parser::FuncdefContext* Python3Parser::Async_stmtContext::funcdef() {
  return getRuleContext<Python3Parser::FuncdefContext>(0);
}

Python3Parser::With_stmtContext* Python3Parser::Async_stmtContext::with_stmt() {
  return getRuleContext<Python3Parser::With_stmtContext>(0);
}

Python3Parser::For_stmtContext* Python3Parser::Async_stmtContext::for_stmt() {
  return getRuleContext<Python3Parser::For_stmtContext>(0);
}


size_t Python3Parser::Async_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleAsync_stmt;
}

void Python3Parser::Async_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsync_stmt(this);
}

void Python3Parser::Async_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsync_stmt(this);
}


std::any Python3Parser::Async_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAsync_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Async_stmtContext* Python3Parser::async_stmt() {
  Async_stmtContext *_localctx = _tracker.createInstance<Async_stmtContext>(_ctx, getState());
  enterRule(_localctx, 80, Python3Parser::RuleAsync_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(682);
    match(Python3Parser::ASYNC);
    setState(686);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::DEF: {
        setState(683);
        funcdef();
        break;
      }

      case Python3Parser::WITH: {
        setState(684);
        with_stmt();
        break;
      }

      case Python3Parser::FOR: {
        setState(685);
        for_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_stmtContext ------------------------------------------------------------------

Python3Parser::If_stmtContext::If_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::If_stmtContext::IF() {
  return getToken(Python3Parser::IF, 0);
}

std::vector<Python3Parser::TestContext *> Python3Parser::If_stmtContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::If_stmtContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::If_stmtContext::COLON() {
  return getTokens(Python3Parser::COLON);
}

tree::TerminalNode* Python3Parser::If_stmtContext::COLON(size_t i) {
  return getToken(Python3Parser::COLON, i);
}

std::vector<Python3Parser::BlockContext *> Python3Parser::If_stmtContext::block() {
  return getRuleContexts<Python3Parser::BlockContext>();
}

Python3Parser::BlockContext* Python3Parser::If_stmtContext::block(size_t i) {
  return getRuleContext<Python3Parser::BlockContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::If_stmtContext::ELIF() {
  return getTokens(Python3Parser::ELIF);
}

tree::TerminalNode* Python3Parser::If_stmtContext::ELIF(size_t i) {
  return getToken(Python3Parser::ELIF, i);
}

tree::TerminalNode* Python3Parser::If_stmtContext::ELSE() {
  return getToken(Python3Parser::ELSE, 0);
}


size_t Python3Parser::If_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleIf_stmt;
}

void Python3Parser::If_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIf_stmt(this);
}

void Python3Parser::If_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIf_stmt(this);
}


std::any Python3Parser::If_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitIf_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::If_stmtContext* Python3Parser::if_stmt() {
  If_stmtContext *_localctx = _tracker.createInstance<If_stmtContext>(_ctx, getState());
  enterRule(_localctx, 82, Python3Parser::RuleIf_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(688);
    match(Python3Parser::IF);
    setState(689);
    test();
    setState(690);
    match(Python3Parser::COLON);
    setState(691);
    block();
    setState(699);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::ELIF) {
      setState(692);
      match(Python3Parser::ELIF);
      setState(693);
      test();
      setState(694);
      match(Python3Parser::COLON);
      setState(695);
      block();
      setState(701);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ELSE) {
      setState(702);
      match(Python3Parser::ELSE);
      setState(703);
      match(Python3Parser::COLON);
      setState(704);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- While_stmtContext ------------------------------------------------------------------

Python3Parser::While_stmtContext::While_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::While_stmtContext::WHILE() {
  return getToken(Python3Parser::WHILE, 0);
}

Python3Parser::TestContext* Python3Parser::While_stmtContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::While_stmtContext::COLON() {
  return getTokens(Python3Parser::COLON);
}

tree::TerminalNode* Python3Parser::While_stmtContext::COLON(size_t i) {
  return getToken(Python3Parser::COLON, i);
}

std::vector<Python3Parser::BlockContext *> Python3Parser::While_stmtContext::block() {
  return getRuleContexts<Python3Parser::BlockContext>();
}

Python3Parser::BlockContext* Python3Parser::While_stmtContext::block(size_t i) {
  return getRuleContext<Python3Parser::BlockContext>(i);
}

tree::TerminalNode* Python3Parser::While_stmtContext::ELSE() {
  return getToken(Python3Parser::ELSE, 0);
}


size_t Python3Parser::While_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleWhile_stmt;
}

void Python3Parser::While_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhile_stmt(this);
}

void Python3Parser::While_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhile_stmt(this);
}


std::any Python3Parser::While_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitWhile_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::While_stmtContext* Python3Parser::while_stmt() {
  While_stmtContext *_localctx = _tracker.createInstance<While_stmtContext>(_ctx, getState());
  enterRule(_localctx, 84, Python3Parser::RuleWhile_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    match(Python3Parser::WHILE);
    setState(708);
    test();
    setState(709);
    match(Python3Parser::COLON);
    setState(710);
    block();
    setState(714);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ELSE) {
      setState(711);
      match(Python3Parser::ELSE);
      setState(712);
      match(Python3Parser::COLON);
      setState(713);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_stmtContext ------------------------------------------------------------------

Python3Parser::For_stmtContext::For_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::For_stmtContext::FOR() {
  return getToken(Python3Parser::FOR, 0);
}

Python3Parser::ExprlistContext* Python3Parser::For_stmtContext::exprlist() {
  return getRuleContext<Python3Parser::ExprlistContext>(0);
}

tree::TerminalNode* Python3Parser::For_stmtContext::IN() {
  return getToken(Python3Parser::IN, 0);
}

Python3Parser::TestlistContext* Python3Parser::For_stmtContext::testlist() {
  return getRuleContext<Python3Parser::TestlistContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::For_stmtContext::COLON() {
  return getTokens(Python3Parser::COLON);
}

tree::TerminalNode* Python3Parser::For_stmtContext::COLON(size_t i) {
  return getToken(Python3Parser::COLON, i);
}

std::vector<Python3Parser::BlockContext *> Python3Parser::For_stmtContext::block() {
  return getRuleContexts<Python3Parser::BlockContext>();
}

Python3Parser::BlockContext* Python3Parser::For_stmtContext::block(size_t i) {
  return getRuleContext<Python3Parser::BlockContext>(i);
}

tree::TerminalNode* Python3Parser::For_stmtContext::ELSE() {
  return getToken(Python3Parser::ELSE, 0);
}


size_t Python3Parser::For_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleFor_stmt;
}

void Python3Parser::For_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_stmt(this);
}

void Python3Parser::For_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_stmt(this);
}


std::any Python3Parser::For_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitFor_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::For_stmtContext* Python3Parser::for_stmt() {
  For_stmtContext *_localctx = _tracker.createInstance<For_stmtContext>(_ctx, getState());
  enterRule(_localctx, 86, Python3Parser::RuleFor_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(716);
    match(Python3Parser::FOR);
    setState(717);
    exprlist();
    setState(718);
    match(Python3Parser::IN);
    setState(719);
    testlist();
    setState(720);
    match(Python3Parser::COLON);
    setState(721);
    block();
    setState(725);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ELSE) {
      setState(722);
      match(Python3Parser::ELSE);
      setState(723);
      match(Python3Parser::COLON);
      setState(724);
      block();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Try_stmtContext ------------------------------------------------------------------

Python3Parser::Try_stmtContext::Try_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Try_stmtContext::TRY() {
  return getToken(Python3Parser::TRY, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::Try_stmtContext::COLON() {
  return getTokens(Python3Parser::COLON);
}

tree::TerminalNode* Python3Parser::Try_stmtContext::COLON(size_t i) {
  return getToken(Python3Parser::COLON, i);
}

std::vector<Python3Parser::BlockContext *> Python3Parser::Try_stmtContext::block() {
  return getRuleContexts<Python3Parser::BlockContext>();
}

Python3Parser::BlockContext* Python3Parser::Try_stmtContext::block(size_t i) {
  return getRuleContext<Python3Parser::BlockContext>(i);
}

tree::TerminalNode* Python3Parser::Try_stmtContext::FINALLY() {
  return getToken(Python3Parser::FINALLY, 0);
}

std::vector<Python3Parser::Except_clauseContext *> Python3Parser::Try_stmtContext::except_clause() {
  return getRuleContexts<Python3Parser::Except_clauseContext>();
}

Python3Parser::Except_clauseContext* Python3Parser::Try_stmtContext::except_clause(size_t i) {
  return getRuleContext<Python3Parser::Except_clauseContext>(i);
}

tree::TerminalNode* Python3Parser::Try_stmtContext::ELSE() {
  return getToken(Python3Parser::ELSE, 0);
}


size_t Python3Parser::Try_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleTry_stmt;
}

void Python3Parser::Try_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTry_stmt(this);
}

void Python3Parser::Try_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTry_stmt(this);
}


std::any Python3Parser::Try_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTry_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Try_stmtContext* Python3Parser::try_stmt() {
  Try_stmtContext *_localctx = _tracker.createInstance<Try_stmtContext>(_ctx, getState());
  enterRule(_localctx, 88, Python3Parser::RuleTry_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(727);
    match(Python3Parser::TRY);
    setState(728);
    match(Python3Parser::COLON);
    setState(729);
    block();
    setState(751);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::EXCEPT: {
        setState(734); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(730);
          except_clause();
          setState(731);
          match(Python3Parser::COLON);
          setState(732);
          block();
          setState(736); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == Python3Parser::EXCEPT);
        setState(741);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::ELSE) {
          setState(738);
          match(Python3Parser::ELSE);
          setState(739);
          match(Python3Parser::COLON);
          setState(740);
          block();
        }
        setState(746);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::FINALLY) {
          setState(743);
          match(Python3Parser::FINALLY);
          setState(744);
          match(Python3Parser::COLON);
          setState(745);
          block();
        }
        break;
      }

      case Python3Parser::FINALLY: {
        setState(748);
        match(Python3Parser::FINALLY);
        setState(749);
        match(Python3Parser::COLON);
        setState(750);
        block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_stmtContext ------------------------------------------------------------------

Python3Parser::With_stmtContext::With_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::With_stmtContext::WITH() {
  return getToken(Python3Parser::WITH, 0);
}

std::vector<Python3Parser::With_itemContext *> Python3Parser::With_stmtContext::with_item() {
  return getRuleContexts<Python3Parser::With_itemContext>();
}

Python3Parser::With_itemContext* Python3Parser::With_stmtContext::with_item(size_t i) {
  return getRuleContext<Python3Parser::With_itemContext>(i);
}

tree::TerminalNode* Python3Parser::With_stmtContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::BlockContext* Python3Parser::With_stmtContext::block() {
  return getRuleContext<Python3Parser::BlockContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::With_stmtContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::With_stmtContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::With_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleWith_stmt;
}

void Python3Parser::With_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_stmt(this);
}

void Python3Parser::With_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_stmt(this);
}


std::any Python3Parser::With_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitWith_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::With_stmtContext* Python3Parser::with_stmt() {
  With_stmtContext *_localctx = _tracker.createInstance<With_stmtContext>(_ctx, getState());
  enterRule(_localctx, 90, Python3Parser::RuleWith_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    match(Python3Parser::WITH);
    setState(754);
    with_item();
    setState(759);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::COMMA) {
      setState(755);
      match(Python3Parser::COMMA);
      setState(756);
      with_item();
      setState(761);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(762);
    match(Python3Parser::COLON);
    setState(763);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_itemContext ------------------------------------------------------------------

Python3Parser::With_itemContext::With_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::TestContext* Python3Parser::With_itemContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

tree::TerminalNode* Python3Parser::With_itemContext::AS() {
  return getToken(Python3Parser::AS, 0);
}

Python3Parser::ExprContext* Python3Parser::With_itemContext::expr() {
  return getRuleContext<Python3Parser::ExprContext>(0);
}


size_t Python3Parser::With_itemContext::getRuleIndex() const {
  return Python3Parser::RuleWith_item;
}

void Python3Parser::With_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_item(this);
}

void Python3Parser::With_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_item(this);
}


std::any Python3Parser::With_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitWith_item(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::With_itemContext* Python3Parser::with_item() {
  With_itemContext *_localctx = _tracker.createInstance<With_itemContext>(_ctx, getState());
  enterRule(_localctx, 92, Python3Parser::RuleWith_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(765);
    test();
    setState(768);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::AS) {
      setState(766);
      match(Python3Parser::AS);
      setState(767);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Except_clauseContext ------------------------------------------------------------------

Python3Parser::Except_clauseContext::Except_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Except_clauseContext::EXCEPT() {
  return getToken(Python3Parser::EXCEPT, 0);
}

Python3Parser::TestContext* Python3Parser::Except_clauseContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

tree::TerminalNode* Python3Parser::Except_clauseContext::AS() {
  return getToken(Python3Parser::AS, 0);
}

Python3Parser::NameContext* Python3Parser::Except_clauseContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::Except_clauseContext::getRuleIndex() const {
  return Python3Parser::RuleExcept_clause;
}

void Python3Parser::Except_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExcept_clause(this);
}

void Python3Parser::Except_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExcept_clause(this);
}


std::any Python3Parser::Except_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitExcept_clause(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Except_clauseContext* Python3Parser::except_clause() {
  Except_clauseContext *_localctx = _tracker.createInstance<Except_clauseContext>(_ctx, getState());
  enterRule(_localctx, 94, Python3Parser::RuleExcept_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(770);
    match(Python3Parser::EXCEPT);
    setState(776);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0)) {
      setState(771);
      test();
      setState(774);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::AS) {
        setState(772);
        match(Python3Parser::AS);
        setState(773);
        name();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContext ------------------------------------------------------------------

Python3Parser::BlockContext::BlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Simple_stmtsContext* Python3Parser::BlockContext::simple_stmts() {
  return getRuleContext<Python3Parser::Simple_stmtsContext>(0);
}

tree::TerminalNode* Python3Parser::BlockContext::NEWLINE() {
  return getToken(Python3Parser::NEWLINE, 0);
}

tree::TerminalNode* Python3Parser::BlockContext::INDENT() {
  return getToken(Python3Parser::INDENT, 0);
}

tree::TerminalNode* Python3Parser::BlockContext::DEDENT() {
  return getToken(Python3Parser::DEDENT, 0);
}

std::vector<Python3Parser::StmtContext *> Python3Parser::BlockContext::stmt() {
  return getRuleContexts<Python3Parser::StmtContext>();
}

Python3Parser::StmtContext* Python3Parser::BlockContext::stmt(size_t i) {
  return getRuleContext<Python3Parser::StmtContext>(i);
}


size_t Python3Parser::BlockContext::getRuleIndex() const {
  return Python3Parser::RuleBlock;
}

void Python3Parser::BlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlock(this);
}

void Python3Parser::BlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlock(this);
}


std::any Python3Parser::BlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitBlock(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::BlockContext* Python3Parser::block() {
  BlockContext *_localctx = _tracker.createInstance<BlockContext>(_ctx, getState());
  enterRule(_localctx, 96, Python3Parser::RuleBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(788);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::ASSERT:
      case Python3Parser::AWAIT:
      case Python3Parser::BREAK:
      case Python3Parser::CONTINUE:
      case Python3Parser::DEL:
      case Python3Parser::FALSE:
      case Python3Parser::FROM:
      case Python3Parser::GLOBAL:
      case Python3Parser::IMPORT:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NONLOCAL:
      case Python3Parser::NOT:
      case Python3Parser::PASS:
      case Python3Parser::RAISE:
      case Python3Parser::RETURN:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::YIELD:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::STAR:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(778);
        simple_stmts();
        break;
      }

      case Python3Parser::NEWLINE: {
        enterOuterAlt(_localctx, 2);
        setState(779);
        match(Python3Parser::NEWLINE);
        setState(780);
        match(Python3Parser::INDENT);
        setState(782); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(781);
          stmt();
          setState(784); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 252254338105339672) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 4206977) != 0));
        setState(786);
        match(Python3Parser::DEDENT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Match_stmtContext ------------------------------------------------------------------

Python3Parser::Match_stmtContext::Match_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Match_stmtContext::MATCH() {
  return getToken(Python3Parser::MATCH, 0);
}

Python3Parser::Subject_exprContext* Python3Parser::Match_stmtContext::subject_expr() {
  return getRuleContext<Python3Parser::Subject_exprContext>(0);
}

tree::TerminalNode* Python3Parser::Match_stmtContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

tree::TerminalNode* Python3Parser::Match_stmtContext::NEWLINE() {
  return getToken(Python3Parser::NEWLINE, 0);
}

tree::TerminalNode* Python3Parser::Match_stmtContext::INDENT() {
  return getToken(Python3Parser::INDENT, 0);
}

tree::TerminalNode* Python3Parser::Match_stmtContext::DEDENT() {
  return getToken(Python3Parser::DEDENT, 0);
}

std::vector<Python3Parser::Case_blockContext *> Python3Parser::Match_stmtContext::case_block() {
  return getRuleContexts<Python3Parser::Case_blockContext>();
}

Python3Parser::Case_blockContext* Python3Parser::Match_stmtContext::case_block(size_t i) {
  return getRuleContext<Python3Parser::Case_blockContext>(i);
}


size_t Python3Parser::Match_stmtContext::getRuleIndex() const {
  return Python3Parser::RuleMatch_stmt;
}

void Python3Parser::Match_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMatch_stmt(this);
}

void Python3Parser::Match_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMatch_stmt(this);
}


std::any Python3Parser::Match_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitMatch_stmt(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Match_stmtContext* Python3Parser::match_stmt() {
  Match_stmtContext *_localctx = _tracker.createInstance<Match_stmtContext>(_ctx, getState());
  enterRule(_localctx, 98, Python3Parser::RuleMatch_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(790);
    match(Python3Parser::MATCH);
    setState(791);
    subject_expr();
    setState(792);
    match(Python3Parser::COLON);
    setState(793);
    match(Python3Parser::NEWLINE);
    setState(794);
    match(Python3Parser::INDENT);
    setState(796); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(795);
      case_block();
      setState(798); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == Python3Parser::CASE);
    setState(800);
    match(Python3Parser::DEDENT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subject_exprContext ------------------------------------------------------------------

Python3Parser::Subject_exprContext::Subject_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Star_named_expressionContext* Python3Parser::Subject_exprContext::star_named_expression() {
  return getRuleContext<Python3Parser::Star_named_expressionContext>(0);
}

tree::TerminalNode* Python3Parser::Subject_exprContext::COMMA() {
  return getToken(Python3Parser::COMMA, 0);
}

Python3Parser::Star_named_expressionsContext* Python3Parser::Subject_exprContext::star_named_expressions() {
  return getRuleContext<Python3Parser::Star_named_expressionsContext>(0);
}

Python3Parser::TestContext* Python3Parser::Subject_exprContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::Subject_exprContext::getRuleIndex() const {
  return Python3Parser::RuleSubject_expr;
}

void Python3Parser::Subject_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubject_expr(this);
}

void Python3Parser::Subject_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubject_expr(this);
}


std::any Python3Parser::Subject_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSubject_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Subject_exprContext* Python3Parser::subject_expr() {
  Subject_exprContext *_localctx = _tracker.createInstance<Subject_exprContext>(_ctx, getState());
  enterRule(_localctx, 100, Python3Parser::RuleSubject_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(802);
      star_named_expression();
      setState(803);
      match(Python3Parser::COMMA);
      setState(805);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(804);
        star_named_expressions();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(807);
      test();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_named_expressionsContext ------------------------------------------------------------------

Python3Parser::Star_named_expressionsContext::Star_named_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> Python3Parser::Star_named_expressionsContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Star_named_expressionsContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}

std::vector<Python3Parser::Star_named_expressionContext *> Python3Parser::Star_named_expressionsContext::star_named_expression() {
  return getRuleContexts<Python3Parser::Star_named_expressionContext>();
}

Python3Parser::Star_named_expressionContext* Python3Parser::Star_named_expressionsContext::star_named_expression(size_t i) {
  return getRuleContext<Python3Parser::Star_named_expressionContext>(i);
}


size_t Python3Parser::Star_named_expressionsContext::getRuleIndex() const {
  return Python3Parser::RuleStar_named_expressions;
}

void Python3Parser::Star_named_expressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_named_expressions(this);
}

void Python3Parser::Star_named_expressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_named_expressions(this);
}


std::any Python3Parser::Star_named_expressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStar_named_expressions(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Star_named_expressionsContext* Python3Parser::star_named_expressions() {
  Star_named_expressionsContext *_localctx = _tracker.createInstance<Star_named_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 102, Python3Parser::RuleStar_named_expressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(810);
    match(Python3Parser::COMMA);
    setState(812); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(811);
      star_named_expression();
      setState(814); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 252238150243451928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0));
    setState(817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(816);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_named_expressionContext ------------------------------------------------------------------

Python3Parser::Star_named_expressionContext::Star_named_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Star_named_expressionContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

Python3Parser::ExprContext* Python3Parser::Star_named_expressionContext::expr() {
  return getRuleContext<Python3Parser::ExprContext>(0);
}

Python3Parser::TestContext* Python3Parser::Star_named_expressionContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::Star_named_expressionContext::getRuleIndex() const {
  return Python3Parser::RuleStar_named_expression;
}

void Python3Parser::Star_named_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_named_expression(this);
}

void Python3Parser::Star_named_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_named_expression(this);
}


std::any Python3Parser::Star_named_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStar_named_expression(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Star_named_expressionContext* Python3Parser::star_named_expression() {
  Star_named_expressionContext *_localctx = _tracker.createInstance<Star_named_expressionContext>(_ctx, getState());
  enterRule(_localctx, 104, Python3Parser::RuleStar_named_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(822);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STAR: {
        enterOuterAlt(_localctx, 1);
        setState(819);
        match(Python3Parser::STAR);
        setState(820);
        expr(0);
        break;
      }

      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(821);
        test();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_blockContext ------------------------------------------------------------------

Python3Parser::Case_blockContext::Case_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Case_blockContext::CASE() {
  return getToken(Python3Parser::CASE, 0);
}

Python3Parser::PatternsContext* Python3Parser::Case_blockContext::patterns() {
  return getRuleContext<Python3Parser::PatternsContext>(0);
}

tree::TerminalNode* Python3Parser::Case_blockContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::BlockContext* Python3Parser::Case_blockContext::block() {
  return getRuleContext<Python3Parser::BlockContext>(0);
}

Python3Parser::GuardContext* Python3Parser::Case_blockContext::guard() {
  return getRuleContext<Python3Parser::GuardContext>(0);
}


size_t Python3Parser::Case_blockContext::getRuleIndex() const {
  return Python3Parser::RuleCase_block;
}

void Python3Parser::Case_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_block(this);
}

void Python3Parser::Case_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_block(this);
}


std::any Python3Parser::Case_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitCase_block(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Case_blockContext* Python3Parser::case_block() {
  Case_blockContext *_localctx = _tracker.createInstance<Case_blockContext>(_ctx, getState());
  enterRule(_localctx, 106, Python3Parser::RuleCase_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(824);
    match(Python3Parser::CASE);
    setState(825);
    patterns();
    setState(827);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::IF) {
      setState(826);
      guard();
    }
    setState(829);
    match(Python3Parser::COLON);
    setState(830);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardContext ------------------------------------------------------------------

Python3Parser::GuardContext::GuardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::GuardContext::IF() {
  return getToken(Python3Parser::IF, 0);
}

Python3Parser::TestContext* Python3Parser::GuardContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::GuardContext::getRuleIndex() const {
  return Python3Parser::RuleGuard;
}

void Python3Parser::GuardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuard(this);
}

void Python3Parser::GuardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuard(this);
}


std::any Python3Parser::GuardContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitGuard(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::GuardContext* Python3Parser::guard() {
  GuardContext *_localctx = _tracker.createInstance<GuardContext>(_ctx, getState());
  enterRule(_localctx, 108, Python3Parser::RuleGuard);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(832);
    match(Python3Parser::IF);
    setState(833);
    test();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternsContext ------------------------------------------------------------------

Python3Parser::PatternsContext::PatternsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Open_sequence_patternContext* Python3Parser::PatternsContext::open_sequence_pattern() {
  return getRuleContext<Python3Parser::Open_sequence_patternContext>(0);
}

Python3Parser::PatternContext* Python3Parser::PatternsContext::pattern() {
  return getRuleContext<Python3Parser::PatternContext>(0);
}


size_t Python3Parser::PatternsContext::getRuleIndex() const {
  return Python3Parser::RulePatterns;
}

void Python3Parser::PatternsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPatterns(this);
}

void Python3Parser::PatternsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPatterns(this);
}


std::any Python3Parser::PatternsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitPatterns(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::PatternsContext* Python3Parser::patterns() {
  PatternsContext *_localctx = _tracker.createInstance<PatternsContext>(_ctx, getState());
  enterRule(_localctx, 110, Python3Parser::RulePatterns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(837);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(835);
      open_sequence_pattern();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(836);
      pattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

Python3Parser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::As_patternContext* Python3Parser::PatternContext::as_pattern() {
  return getRuleContext<Python3Parser::As_patternContext>(0);
}

Python3Parser::Or_patternContext* Python3Parser::PatternContext::or_pattern() {
  return getRuleContext<Python3Parser::Or_patternContext>(0);
}


size_t Python3Parser::PatternContext::getRuleIndex() const {
  return Python3Parser::RulePattern;
}

void Python3Parser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void Python3Parser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any Python3Parser::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::PatternContext* Python3Parser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 112, Python3Parser::RulePattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(841);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(839);
      as_pattern();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(840);
      or_pattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- As_patternContext ------------------------------------------------------------------

Python3Parser::As_patternContext::As_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Or_patternContext* Python3Parser::As_patternContext::or_pattern() {
  return getRuleContext<Python3Parser::Or_patternContext>(0);
}

tree::TerminalNode* Python3Parser::As_patternContext::AS() {
  return getToken(Python3Parser::AS, 0);
}

Python3Parser::Pattern_capture_targetContext* Python3Parser::As_patternContext::pattern_capture_target() {
  return getRuleContext<Python3Parser::Pattern_capture_targetContext>(0);
}


size_t Python3Parser::As_patternContext::getRuleIndex() const {
  return Python3Parser::RuleAs_pattern;
}

void Python3Parser::As_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAs_pattern(this);
}

void Python3Parser::As_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAs_pattern(this);
}


std::any Python3Parser::As_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAs_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::As_patternContext* Python3Parser::as_pattern() {
  As_patternContext *_localctx = _tracker.createInstance<As_patternContext>(_ctx, getState());
  enterRule(_localctx, 114, Python3Parser::RuleAs_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(843);
    or_pattern();
    setState(844);
    match(Python3Parser::AS);
    setState(845);
    pattern_capture_target();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Or_patternContext ------------------------------------------------------------------

Python3Parser::Or_patternContext::Or_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Closed_patternContext *> Python3Parser::Or_patternContext::closed_pattern() {
  return getRuleContexts<Python3Parser::Closed_patternContext>();
}

Python3Parser::Closed_patternContext* Python3Parser::Or_patternContext::closed_pattern(size_t i) {
  return getRuleContext<Python3Parser::Closed_patternContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Or_patternContext::OR_OP() {
  return getTokens(Python3Parser::OR_OP);
}

tree::TerminalNode* Python3Parser::Or_patternContext::OR_OP(size_t i) {
  return getToken(Python3Parser::OR_OP, i);
}


size_t Python3Parser::Or_patternContext::getRuleIndex() const {
  return Python3Parser::RuleOr_pattern;
}

void Python3Parser::Or_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOr_pattern(this);
}

void Python3Parser::Or_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOr_pattern(this);
}


std::any Python3Parser::Or_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitOr_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Or_patternContext* Python3Parser::or_pattern() {
  Or_patternContext *_localctx = _tracker.createInstance<Or_patternContext>(_ctx, getState());
  enterRule(_localctx, 116, Python3Parser::RuleOr_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(847);
    closed_pattern();
    setState(852);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::OR_OP) {
      setState(848);
      match(Python3Parser::OR_OP);
      setState(849);
      closed_pattern();
      setState(854);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Closed_patternContext ------------------------------------------------------------------

Python3Parser::Closed_patternContext::Closed_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Literal_patternContext* Python3Parser::Closed_patternContext::literal_pattern() {
  return getRuleContext<Python3Parser::Literal_patternContext>(0);
}

Python3Parser::Capture_patternContext* Python3Parser::Closed_patternContext::capture_pattern() {
  return getRuleContext<Python3Parser::Capture_patternContext>(0);
}

Python3Parser::Wildcard_patternContext* Python3Parser::Closed_patternContext::wildcard_pattern() {
  return getRuleContext<Python3Parser::Wildcard_patternContext>(0);
}

Python3Parser::Value_patternContext* Python3Parser::Closed_patternContext::value_pattern() {
  return getRuleContext<Python3Parser::Value_patternContext>(0);
}

Python3Parser::Group_patternContext* Python3Parser::Closed_patternContext::group_pattern() {
  return getRuleContext<Python3Parser::Group_patternContext>(0);
}

Python3Parser::Sequence_patternContext* Python3Parser::Closed_patternContext::sequence_pattern() {
  return getRuleContext<Python3Parser::Sequence_patternContext>(0);
}

Python3Parser::Mapping_patternContext* Python3Parser::Closed_patternContext::mapping_pattern() {
  return getRuleContext<Python3Parser::Mapping_patternContext>(0);
}

Python3Parser::Class_patternContext* Python3Parser::Closed_patternContext::class_pattern() {
  return getRuleContext<Python3Parser::Class_patternContext>(0);
}


size_t Python3Parser::Closed_patternContext::getRuleIndex() const {
  return Python3Parser::RuleClosed_pattern;
}

void Python3Parser::Closed_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClosed_pattern(this);
}

void Python3Parser::Closed_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClosed_pattern(this);
}


std::any Python3Parser::Closed_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitClosed_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Closed_patternContext* Python3Parser::closed_pattern() {
  Closed_patternContext *_localctx = _tracker.createInstance<Closed_patternContext>(_ctx, getState());
  enterRule(_localctx, 118, Python3Parser::RuleClosed_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(863);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(855);
      literal_pattern();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(856);
      capture_pattern();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(857);
      wildcard_pattern();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(858);
      value_pattern();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(859);
      group_pattern();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(860);
      sequence_pattern();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(861);
      mapping_pattern();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(862);
      class_pattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_patternContext ------------------------------------------------------------------

Python3Parser::Literal_patternContext::Literal_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Signed_numberContext* Python3Parser::Literal_patternContext::signed_number() {
  return getRuleContext<Python3Parser::Signed_numberContext>(0);
}

Python3Parser::Complex_numberContext* Python3Parser::Literal_patternContext::complex_number() {
  return getRuleContext<Python3Parser::Complex_numberContext>(0);
}

Python3Parser::StringsContext* Python3Parser::Literal_patternContext::strings() {
  return getRuleContext<Python3Parser::StringsContext>(0);
}

tree::TerminalNode* Python3Parser::Literal_patternContext::NONE() {
  return getToken(Python3Parser::NONE, 0);
}

tree::TerminalNode* Python3Parser::Literal_patternContext::TRUE() {
  return getToken(Python3Parser::TRUE, 0);
}

tree::TerminalNode* Python3Parser::Literal_patternContext::FALSE() {
  return getToken(Python3Parser::FALSE, 0);
}


size_t Python3Parser::Literal_patternContext::getRuleIndex() const {
  return Python3Parser::RuleLiteral_pattern;
}

void Python3Parser::Literal_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_pattern(this);
}

void Python3Parser::Literal_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_pattern(this);
}


std::any Python3Parser::Literal_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitLiteral_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Literal_patternContext* Python3Parser::literal_pattern() {
  Literal_patternContext *_localctx = _tracker.createInstance<Literal_patternContext>(_ctx, getState());
  enterRule(_localctx, 120, Python3Parser::RuleLiteral_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(873);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(865);
      signed_number();
      setState(866);

      if (!( this->CannotBePlusMinus() )) throw FailedPredicateException(this, " this->CannotBePlusMinus() ");
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(868);
      complex_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(869);
      strings();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(870);
      match(Python3Parser::NONE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(871);
      match(Python3Parser::TRUE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(872);
      match(Python3Parser::FALSE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_exprContext ------------------------------------------------------------------

Python3Parser::Literal_exprContext::Literal_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Signed_numberContext* Python3Parser::Literal_exprContext::signed_number() {
  return getRuleContext<Python3Parser::Signed_numberContext>(0);
}

Python3Parser::Complex_numberContext* Python3Parser::Literal_exprContext::complex_number() {
  return getRuleContext<Python3Parser::Complex_numberContext>(0);
}

Python3Parser::StringsContext* Python3Parser::Literal_exprContext::strings() {
  return getRuleContext<Python3Parser::StringsContext>(0);
}

tree::TerminalNode* Python3Parser::Literal_exprContext::NONE() {
  return getToken(Python3Parser::NONE, 0);
}

tree::TerminalNode* Python3Parser::Literal_exprContext::TRUE() {
  return getToken(Python3Parser::TRUE, 0);
}

tree::TerminalNode* Python3Parser::Literal_exprContext::FALSE() {
  return getToken(Python3Parser::FALSE, 0);
}


size_t Python3Parser::Literal_exprContext::getRuleIndex() const {
  return Python3Parser::RuleLiteral_expr;
}

void Python3Parser::Literal_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_expr(this);
}

void Python3Parser::Literal_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_expr(this);
}


std::any Python3Parser::Literal_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitLiteral_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Literal_exprContext* Python3Parser::literal_expr() {
  Literal_exprContext *_localctx = _tracker.createInstance<Literal_exprContext>(_ctx, getState());
  enterRule(_localctx, 122, Python3Parser::RuleLiteral_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(883);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(875);
      signed_number();
      setState(876);

      if (!( this->CannotBePlusMinus() )) throw FailedPredicateException(this, " this->CannotBePlusMinus() ");
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(878);
      complex_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(879);
      strings();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(880);
      match(Python3Parser::NONE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(881);
      match(Python3Parser::TRUE);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(882);
      match(Python3Parser::FALSE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Complex_numberContext ------------------------------------------------------------------

Python3Parser::Complex_numberContext::Complex_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Signed_real_numberContext* Python3Parser::Complex_numberContext::signed_real_number() {
  return getRuleContext<Python3Parser::Signed_real_numberContext>(0);
}

tree::TerminalNode* Python3Parser::Complex_numberContext::ADD() {
  return getToken(Python3Parser::ADD, 0);
}

Python3Parser::Imaginary_numberContext* Python3Parser::Complex_numberContext::imaginary_number() {
  return getRuleContext<Python3Parser::Imaginary_numberContext>(0);
}

tree::TerminalNode* Python3Parser::Complex_numberContext::MINUS() {
  return getToken(Python3Parser::MINUS, 0);
}


size_t Python3Parser::Complex_numberContext::getRuleIndex() const {
  return Python3Parser::RuleComplex_number;
}

void Python3Parser::Complex_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComplex_number(this);
}

void Python3Parser::Complex_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComplex_number(this);
}


std::any Python3Parser::Complex_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComplex_number(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Complex_numberContext* Python3Parser::complex_number() {
  Complex_numberContext *_localctx = _tracker.createInstance<Complex_numberContext>(_ctx, getState());
  enterRule(_localctx, 124, Python3Parser::RuleComplex_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(893);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(885);
      signed_real_number();
      setState(886);
      match(Python3Parser::ADD);
      setState(887);
      imaginary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(889);
      signed_real_number();
      setState(890);
      match(Python3Parser::MINUS);
      setState(891);
      imaginary_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_numberContext ------------------------------------------------------------------

Python3Parser::Signed_numberContext::Signed_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Signed_numberContext::NUMBER() {
  return getToken(Python3Parser::NUMBER, 0);
}

tree::TerminalNode* Python3Parser::Signed_numberContext::MINUS() {
  return getToken(Python3Parser::MINUS, 0);
}


size_t Python3Parser::Signed_numberContext::getRuleIndex() const {
  return Python3Parser::RuleSigned_number;
}

void Python3Parser::Signed_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_number(this);
}

void Python3Parser::Signed_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_number(this);
}


std::any Python3Parser::Signed_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSigned_number(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Signed_numberContext* Python3Parser::signed_number() {
  Signed_numberContext *_localctx = _tracker.createInstance<Signed_numberContext>(_ctx, getState());
  enterRule(_localctx, 126, Python3Parser::RuleSigned_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(898);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(895);
        match(Python3Parser::NUMBER);
        break;
      }

      case Python3Parser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(896);
        match(Python3Parser::MINUS);
        setState(897);
        match(Python3Parser::NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_real_numberContext ------------------------------------------------------------------

Python3Parser::Signed_real_numberContext::Signed_real_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Real_numberContext* Python3Parser::Signed_real_numberContext::real_number() {
  return getRuleContext<Python3Parser::Real_numberContext>(0);
}

tree::TerminalNode* Python3Parser::Signed_real_numberContext::MINUS() {
  return getToken(Python3Parser::MINUS, 0);
}


size_t Python3Parser::Signed_real_numberContext::getRuleIndex() const {
  return Python3Parser::RuleSigned_real_number;
}

void Python3Parser::Signed_real_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_real_number(this);
}

void Python3Parser::Signed_real_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_real_number(this);
}


std::any Python3Parser::Signed_real_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSigned_real_number(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Signed_real_numberContext* Python3Parser::signed_real_number() {
  Signed_real_numberContext *_localctx = _tracker.createInstance<Signed_real_numberContext>(_ctx, getState());
  enterRule(_localctx, 128, Python3Parser::RuleSigned_real_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(900);
        real_number();
        break;
      }

      case Python3Parser::MINUS: {
        enterOuterAlt(_localctx, 2);
        setState(901);
        match(Python3Parser::MINUS);
        setState(902);
        real_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_numberContext ------------------------------------------------------------------

Python3Parser::Real_numberContext::Real_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Real_numberContext::NUMBER() {
  return getToken(Python3Parser::NUMBER, 0);
}


size_t Python3Parser::Real_numberContext::getRuleIndex() const {
  return Python3Parser::RuleReal_number;
}

void Python3Parser::Real_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_number(this);
}

void Python3Parser::Real_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_number(this);
}


std::any Python3Parser::Real_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitReal_number(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Real_numberContext* Python3Parser::real_number() {
  Real_numberContext *_localctx = _tracker.createInstance<Real_numberContext>(_ctx, getState());
  enterRule(_localctx, 130, Python3Parser::RuleReal_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(905);
    match(Python3Parser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Imaginary_numberContext ------------------------------------------------------------------

Python3Parser::Imaginary_numberContext::Imaginary_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Imaginary_numberContext::NUMBER() {
  return getToken(Python3Parser::NUMBER, 0);
}


size_t Python3Parser::Imaginary_numberContext::getRuleIndex() const {
  return Python3Parser::RuleImaginary_number;
}

void Python3Parser::Imaginary_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImaginary_number(this);
}

void Python3Parser::Imaginary_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImaginary_number(this);
}


std::any Python3Parser::Imaginary_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitImaginary_number(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Imaginary_numberContext* Python3Parser::imaginary_number() {
  Imaginary_numberContext *_localctx = _tracker.createInstance<Imaginary_numberContext>(_ctx, getState());
  enterRule(_localctx, 132, Python3Parser::RuleImaginary_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(907);
    match(Python3Parser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Capture_patternContext ------------------------------------------------------------------

Python3Parser::Capture_patternContext::Capture_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Pattern_capture_targetContext* Python3Parser::Capture_patternContext::pattern_capture_target() {
  return getRuleContext<Python3Parser::Pattern_capture_targetContext>(0);
}


size_t Python3Parser::Capture_patternContext::getRuleIndex() const {
  return Python3Parser::RuleCapture_pattern;
}

void Python3Parser::Capture_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture_pattern(this);
}

void Python3Parser::Capture_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture_pattern(this);
}


std::any Python3Parser::Capture_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitCapture_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Capture_patternContext* Python3Parser::capture_pattern() {
  Capture_patternContext *_localctx = _tracker.createInstance<Capture_patternContext>(_ctx, getState());
  enterRule(_localctx, 134, Python3Parser::RuleCapture_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(909);
    pattern_capture_target();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pattern_capture_targetContext ------------------------------------------------------------------

Python3Parser::Pattern_capture_targetContext::Pattern_capture_targetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::NameContext* Python3Parser::Pattern_capture_targetContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::Pattern_capture_targetContext::getRuleIndex() const {
  return Python3Parser::RulePattern_capture_target;
}

void Python3Parser::Pattern_capture_targetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern_capture_target(this);
}

void Python3Parser::Pattern_capture_targetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern_capture_target(this);
}


std::any Python3Parser::Pattern_capture_targetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitPattern_capture_target(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Pattern_capture_targetContext* Python3Parser::pattern_capture_target() {
  Pattern_capture_targetContext *_localctx = _tracker.createInstance<Pattern_capture_targetContext>(_ctx, getState());
  enterRule(_localctx, 136, Python3Parser::RulePattern_capture_target);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(911);
    name();
    setState(912);

    if (!( this->CannotBeDotLpEq() )) throw FailedPredicateException(this, " this->CannotBeDotLpEq() ");
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wildcard_patternContext ------------------------------------------------------------------

Python3Parser::Wildcard_patternContext::Wildcard_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Wildcard_patternContext::UNDERSCORE() {
  return getToken(Python3Parser::UNDERSCORE, 0);
}


size_t Python3Parser::Wildcard_patternContext::getRuleIndex() const {
  return Python3Parser::RuleWildcard_pattern;
}

void Python3Parser::Wildcard_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildcard_pattern(this);
}

void Python3Parser::Wildcard_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildcard_pattern(this);
}


std::any Python3Parser::Wildcard_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitWildcard_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Wildcard_patternContext* Python3Parser::wildcard_pattern() {
  Wildcard_patternContext *_localctx = _tracker.createInstance<Wildcard_patternContext>(_ctx, getState());
  enterRule(_localctx, 138, Python3Parser::RuleWildcard_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    match(Python3Parser::UNDERSCORE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_patternContext ------------------------------------------------------------------

Python3Parser::Value_patternContext::Value_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::AttrContext* Python3Parser::Value_patternContext::attr() {
  return getRuleContext<Python3Parser::AttrContext>(0);
}


size_t Python3Parser::Value_patternContext::getRuleIndex() const {
  return Python3Parser::RuleValue_pattern;
}

void Python3Parser::Value_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_pattern(this);
}

void Python3Parser::Value_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_pattern(this);
}


std::any Python3Parser::Value_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitValue_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Value_patternContext* Python3Parser::value_pattern() {
  Value_patternContext *_localctx = _tracker.createInstance<Value_patternContext>(_ctx, getState());
  enterRule(_localctx, 140, Python3Parser::RuleValue_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(916);
    attr();
    setState(917);

    if (!( this->CannotBeDotLpEq() )) throw FailedPredicateException(this, " this->CannotBeDotLpEq() ");
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttrContext ------------------------------------------------------------------

Python3Parser::AttrContext::AttrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::NameContext *> Python3Parser::AttrContext::name() {
  return getRuleContexts<Python3Parser::NameContext>();
}

Python3Parser::NameContext* Python3Parser::AttrContext::name(size_t i) {
  return getRuleContext<Python3Parser::NameContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::AttrContext::DOT() {
  return getTokens(Python3Parser::DOT);
}

tree::TerminalNode* Python3Parser::AttrContext::DOT(size_t i) {
  return getToken(Python3Parser::DOT, i);
}


size_t Python3Parser::AttrContext::getRuleIndex() const {
  return Python3Parser::RuleAttr;
}

void Python3Parser::AttrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttr(this);
}

void Python3Parser::AttrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttr(this);
}


std::any Python3Parser::AttrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAttr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::AttrContext* Python3Parser::attr() {
  AttrContext *_localctx = _tracker.createInstance<AttrContext>(_ctx, getState());
  enterRule(_localctx, 142, Python3Parser::RuleAttr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(919);
    name();
    setState(922); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(920);
              match(Python3Parser::DOT);
              setState(921);
              name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(924); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_or_attrContext ------------------------------------------------------------------

Python3Parser::Name_or_attrContext::Name_or_attrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::AttrContext* Python3Parser::Name_or_attrContext::attr() {
  return getRuleContext<Python3Parser::AttrContext>(0);
}

Python3Parser::NameContext* Python3Parser::Name_or_attrContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::Name_or_attrContext::getRuleIndex() const {
  return Python3Parser::RuleName_or_attr;
}

void Python3Parser::Name_or_attrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName_or_attr(this);
}

void Python3Parser::Name_or_attrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName_or_attr(this);
}


std::any Python3Parser::Name_or_attrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitName_or_attr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Name_or_attrContext* Python3Parser::name_or_attr() {
  Name_or_attrContext *_localctx = _tracker.createInstance<Name_or_attrContext>(_ctx, getState());
  enterRule(_localctx, 144, Python3Parser::RuleName_or_attr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(928);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(926);
      attr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(927);
      name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Group_patternContext ------------------------------------------------------------------

Python3Parser::Group_patternContext::Group_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Group_patternContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

Python3Parser::PatternContext* Python3Parser::Group_patternContext::pattern() {
  return getRuleContext<Python3Parser::PatternContext>(0);
}

tree::TerminalNode* Python3Parser::Group_patternContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}


size_t Python3Parser::Group_patternContext::getRuleIndex() const {
  return Python3Parser::RuleGroup_pattern;
}

void Python3Parser::Group_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroup_pattern(this);
}

void Python3Parser::Group_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroup_pattern(this);
}


std::any Python3Parser::Group_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitGroup_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Group_patternContext* Python3Parser::group_pattern() {
  Group_patternContext *_localctx = _tracker.createInstance<Group_patternContext>(_ctx, getState());
  enterRule(_localctx, 146, Python3Parser::RuleGroup_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    match(Python3Parser::OPEN_PAREN);
    setState(931);
    pattern();
    setState(932);
    match(Python3Parser::CLOSE_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequence_patternContext ------------------------------------------------------------------

Python3Parser::Sequence_patternContext::Sequence_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Sequence_patternContext::OPEN_BRACK() {
  return getToken(Python3Parser::OPEN_BRACK, 0);
}

tree::TerminalNode* Python3Parser::Sequence_patternContext::CLOSE_BRACK() {
  return getToken(Python3Parser::CLOSE_BRACK, 0);
}

Python3Parser::Maybe_sequence_patternContext* Python3Parser::Sequence_patternContext::maybe_sequence_pattern() {
  return getRuleContext<Python3Parser::Maybe_sequence_patternContext>(0);
}

tree::TerminalNode* Python3Parser::Sequence_patternContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::Sequence_patternContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::Open_sequence_patternContext* Python3Parser::Sequence_patternContext::open_sequence_pattern() {
  return getRuleContext<Python3Parser::Open_sequence_patternContext>(0);
}


size_t Python3Parser::Sequence_patternContext::getRuleIndex() const {
  return Python3Parser::RuleSequence_pattern;
}

void Python3Parser::Sequence_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequence_pattern(this);
}

void Python3Parser::Sequence_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequence_pattern(this);
}


std::any Python3Parser::Sequence_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSequence_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Sequence_patternContext* Python3Parser::sequence_pattern() {
  Sequence_patternContext *_localctx = _tracker.createInstance<Sequence_patternContext>(_ctx, getState());
  enterRule(_localctx, 148, Python3Parser::RuleSequence_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(944);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::OPEN_BRACK: {
        enterOuterAlt(_localctx, 1);
        setState(934);
        match(Python3Parser::OPEN_BRACK);
        setState(936);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 216209344097681432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 8449) != 0)) {
          setState(935);
          maybe_sequence_pattern();
        }
        setState(938);
        match(Python3Parser::CLOSE_BRACK);
        break;
      }

      case Python3Parser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(939);
        match(Python3Parser::OPEN_PAREN);
        setState(941);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 216209344097681432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 8449) != 0)) {
          setState(940);
          open_sequence_pattern();
        }
        setState(943);
        match(Python3Parser::CLOSE_PAREN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Open_sequence_patternContext ------------------------------------------------------------------

Python3Parser::Open_sequence_patternContext::Open_sequence_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Maybe_star_patternContext* Python3Parser::Open_sequence_patternContext::maybe_star_pattern() {
  return getRuleContext<Python3Parser::Maybe_star_patternContext>(0);
}

tree::TerminalNode* Python3Parser::Open_sequence_patternContext::COMMA() {
  return getToken(Python3Parser::COMMA, 0);
}

Python3Parser::Maybe_sequence_patternContext* Python3Parser::Open_sequence_patternContext::maybe_sequence_pattern() {
  return getRuleContext<Python3Parser::Maybe_sequence_patternContext>(0);
}


size_t Python3Parser::Open_sequence_patternContext::getRuleIndex() const {
  return Python3Parser::RuleOpen_sequence_pattern;
}

void Python3Parser::Open_sequence_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpen_sequence_pattern(this);
}

void Python3Parser::Open_sequence_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpen_sequence_pattern(this);
}


std::any Python3Parser::Open_sequence_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitOpen_sequence_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Open_sequence_patternContext* Python3Parser::open_sequence_pattern() {
  Open_sequence_patternContext *_localctx = _tracker.createInstance<Open_sequence_patternContext>(_ctx, getState());
  enterRule(_localctx, 150, Python3Parser::RuleOpen_sequence_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(946);
    maybe_star_pattern();
    setState(947);
    match(Python3Parser::COMMA);
    setState(949);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 216209344097681432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8449) != 0)) {
      setState(948);
      maybe_sequence_pattern();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Maybe_sequence_patternContext ------------------------------------------------------------------

Python3Parser::Maybe_sequence_patternContext::Maybe_sequence_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Maybe_star_patternContext *> Python3Parser::Maybe_sequence_patternContext::maybe_star_pattern() {
  return getRuleContexts<Python3Parser::Maybe_star_patternContext>();
}

Python3Parser::Maybe_star_patternContext* Python3Parser::Maybe_sequence_patternContext::maybe_star_pattern(size_t i) {
  return getRuleContext<Python3Parser::Maybe_star_patternContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Maybe_sequence_patternContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Maybe_sequence_patternContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Maybe_sequence_patternContext::getRuleIndex() const {
  return Python3Parser::RuleMaybe_sequence_pattern;
}

void Python3Parser::Maybe_sequence_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaybe_sequence_pattern(this);
}

void Python3Parser::Maybe_sequence_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaybe_sequence_pattern(this);
}


std::any Python3Parser::Maybe_sequence_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitMaybe_sequence_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Maybe_sequence_patternContext* Python3Parser::maybe_sequence_pattern() {
  Maybe_sequence_patternContext *_localctx = _tracker.createInstance<Maybe_sequence_patternContext>(_ctx, getState());
  enterRule(_localctx, 152, Python3Parser::RuleMaybe_sequence_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(951);
    maybe_star_pattern();
    setState(956);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(952);
        match(Python3Parser::COMMA);
        setState(953);
        maybe_star_pattern(); 
      }
      setState(958);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    }
    setState(960);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(959);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Maybe_star_patternContext ------------------------------------------------------------------

Python3Parser::Maybe_star_patternContext::Maybe_star_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Star_patternContext* Python3Parser::Maybe_star_patternContext::star_pattern() {
  return getRuleContext<Python3Parser::Star_patternContext>(0);
}

Python3Parser::PatternContext* Python3Parser::Maybe_star_patternContext::pattern() {
  return getRuleContext<Python3Parser::PatternContext>(0);
}


size_t Python3Parser::Maybe_star_patternContext::getRuleIndex() const {
  return Python3Parser::RuleMaybe_star_pattern;
}

void Python3Parser::Maybe_star_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaybe_star_pattern(this);
}

void Python3Parser::Maybe_star_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaybe_star_pattern(this);
}


std::any Python3Parser::Maybe_star_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitMaybe_star_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Maybe_star_patternContext* Python3Parser::maybe_star_pattern() {
  Maybe_star_patternContext *_localctx = _tracker.createInstance<Maybe_star_patternContext>(_ctx, getState());
  enterRule(_localctx, 154, Python3Parser::RuleMaybe_star_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(964);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STAR: {
        enterOuterAlt(_localctx, 1);
        setState(962);
        star_pattern();
        break;
      }

      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::MINUS:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(963);
        pattern();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_patternContext ------------------------------------------------------------------

Python3Parser::Star_patternContext::Star_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Star_patternContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

Python3Parser::Pattern_capture_targetContext* Python3Parser::Star_patternContext::pattern_capture_target() {
  return getRuleContext<Python3Parser::Pattern_capture_targetContext>(0);
}

Python3Parser::Wildcard_patternContext* Python3Parser::Star_patternContext::wildcard_pattern() {
  return getRuleContext<Python3Parser::Wildcard_patternContext>(0);
}


size_t Python3Parser::Star_patternContext::getRuleIndex() const {
  return Python3Parser::RuleStar_pattern;
}

void Python3Parser::Star_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_pattern(this);
}

void Python3Parser::Star_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_pattern(this);
}


std::any Python3Parser::Star_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStar_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Star_patternContext* Python3Parser::star_pattern() {
  Star_patternContext *_localctx = _tracker.createInstance<Star_patternContext>(_ctx, getState());
  enterRule(_localctx, 156, Python3Parser::RuleStar_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(970);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(966);
      match(Python3Parser::STAR);
      setState(967);
      pattern_capture_target();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(968);
      match(Python3Parser::STAR);
      setState(969);
      wildcard_pattern();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mapping_patternContext ------------------------------------------------------------------

Python3Parser::Mapping_patternContext::Mapping_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Mapping_patternContext::OPEN_BRACE() {
  return getToken(Python3Parser::OPEN_BRACE, 0);
}

tree::TerminalNode* Python3Parser::Mapping_patternContext::CLOSE_BRACE() {
  return getToken(Python3Parser::CLOSE_BRACE, 0);
}

Python3Parser::Double_star_patternContext* Python3Parser::Mapping_patternContext::double_star_pattern() {
  return getRuleContext<Python3Parser::Double_star_patternContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::Mapping_patternContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Mapping_patternContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}

Python3Parser::Items_patternContext* Python3Parser::Mapping_patternContext::items_pattern() {
  return getRuleContext<Python3Parser::Items_patternContext>(0);
}


size_t Python3Parser::Mapping_patternContext::getRuleIndex() const {
  return Python3Parser::RuleMapping_pattern;
}

void Python3Parser::Mapping_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMapping_pattern(this);
}

void Python3Parser::Mapping_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMapping_pattern(this);
}


std::any Python3Parser::Mapping_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitMapping_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Mapping_patternContext* Python3Parser::mapping_pattern() {
  Mapping_patternContext *_localctx = _tracker.createInstance<Mapping_patternContext>(_ctx, getState());
  enterRule(_localctx, 158, Python3Parser::RuleMapping_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(997);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(972);
      match(Python3Parser::OPEN_BRACE);
      setState(973);
      match(Python3Parser::CLOSE_BRACE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(974);
      match(Python3Parser::OPEN_BRACE);
      setState(975);
      double_star_pattern();
      setState(977);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(976);
        match(Python3Parser::COMMA);
      }
      setState(979);
      match(Python3Parser::CLOSE_BRACE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(981);
      match(Python3Parser::OPEN_BRACE);
      setState(982);
      items_pattern();
      setState(983);
      match(Python3Parser::COMMA);
      setState(984);
      double_star_pattern();
      setState(986);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(985);
        match(Python3Parser::COMMA);
      }
      setState(988);
      match(Python3Parser::CLOSE_BRACE);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(990);
      match(Python3Parser::OPEN_BRACE);
      setState(991);
      items_pattern();
      setState(993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(992);
        match(Python3Parser::COMMA);
      }
      setState(995);
      match(Python3Parser::CLOSE_BRACE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Items_patternContext ------------------------------------------------------------------

Python3Parser::Items_patternContext::Items_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Key_value_patternContext *> Python3Parser::Items_patternContext::key_value_pattern() {
  return getRuleContexts<Python3Parser::Key_value_patternContext>();
}

Python3Parser::Key_value_patternContext* Python3Parser::Items_patternContext::key_value_pattern(size_t i) {
  return getRuleContext<Python3Parser::Key_value_patternContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Items_patternContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Items_patternContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Items_patternContext::getRuleIndex() const {
  return Python3Parser::RuleItems_pattern;
}

void Python3Parser::Items_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterItems_pattern(this);
}

void Python3Parser::Items_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitItems_pattern(this);
}


std::any Python3Parser::Items_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitItems_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Items_patternContext* Python3Parser::items_pattern() {
  Items_patternContext *_localctx = _tracker.createInstance<Items_patternContext>(_ctx, getState());
  enterRule(_localctx, 160, Python3Parser::RuleItems_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(999);
    key_value_pattern();
    setState(1004);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1000);
        match(Python3Parser::COMMA);
        setState(1001);
        key_value_pattern(); 
      }
      setState(1006);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Key_value_patternContext ------------------------------------------------------------------

Python3Parser::Key_value_patternContext::Key_value_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Key_value_patternContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::PatternContext* Python3Parser::Key_value_patternContext::pattern() {
  return getRuleContext<Python3Parser::PatternContext>(0);
}

Python3Parser::Literal_exprContext* Python3Parser::Key_value_patternContext::literal_expr() {
  return getRuleContext<Python3Parser::Literal_exprContext>(0);
}

Python3Parser::AttrContext* Python3Parser::Key_value_patternContext::attr() {
  return getRuleContext<Python3Parser::AttrContext>(0);
}


size_t Python3Parser::Key_value_patternContext::getRuleIndex() const {
  return Python3Parser::RuleKey_value_pattern;
}

void Python3Parser::Key_value_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKey_value_pattern(this);
}

void Python3Parser::Key_value_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKey_value_pattern(this);
}


std::any Python3Parser::Key_value_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitKey_value_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Key_value_patternContext* Python3Parser::key_value_pattern() {
  Key_value_patternContext *_localctx = _tracker.createInstance<Key_value_patternContext>(_ctx, getState());
  enterRule(_localctx, 162, Python3Parser::RuleKey_value_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::FALSE:
      case Python3Parser::NONE:
      case Python3Parser::TRUE:
      case Python3Parser::MINUS: {
        setState(1007);
        literal_expr();
        break;
      }

      case Python3Parser::MATCH:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME: {
        setState(1008);
        attr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1011);
    match(Python3Parser::COLON);
    setState(1012);
    pattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Double_star_patternContext ------------------------------------------------------------------

Python3Parser::Double_star_patternContext::Double_star_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Double_star_patternContext::POWER() {
  return getToken(Python3Parser::POWER, 0);
}

Python3Parser::Pattern_capture_targetContext* Python3Parser::Double_star_patternContext::pattern_capture_target() {
  return getRuleContext<Python3Parser::Pattern_capture_targetContext>(0);
}


size_t Python3Parser::Double_star_patternContext::getRuleIndex() const {
  return Python3Parser::RuleDouble_star_pattern;
}

void Python3Parser::Double_star_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDouble_star_pattern(this);
}

void Python3Parser::Double_star_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDouble_star_pattern(this);
}


std::any Python3Parser::Double_star_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDouble_star_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Double_star_patternContext* Python3Parser::double_star_pattern() {
  Double_star_patternContext *_localctx = _tracker.createInstance<Double_star_patternContext>(_ctx, getState());
  enterRule(_localctx, 164, Python3Parser::RuleDouble_star_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1014);
    match(Python3Parser::POWER);
    setState(1015);
    pattern_capture_target();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_patternContext ------------------------------------------------------------------

Python3Parser::Class_patternContext::Class_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Name_or_attrContext* Python3Parser::Class_patternContext::name_or_attr() {
  return getRuleContext<Python3Parser::Name_or_attrContext>(0);
}

tree::TerminalNode* Python3Parser::Class_patternContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::Class_patternContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::Positional_patternsContext* Python3Parser::Class_patternContext::positional_patterns() {
  return getRuleContext<Python3Parser::Positional_patternsContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::Class_patternContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Class_patternContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}

Python3Parser::Keyword_patternsContext* Python3Parser::Class_patternContext::keyword_patterns() {
  return getRuleContext<Python3Parser::Keyword_patternsContext>(0);
}


size_t Python3Parser::Class_patternContext::getRuleIndex() const {
  return Python3Parser::RuleClass_pattern;
}

void Python3Parser::Class_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_pattern(this);
}

void Python3Parser::Class_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_pattern(this);
}


std::any Python3Parser::Class_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitClass_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Class_patternContext* Python3Parser::class_pattern() {
  Class_patternContext *_localctx = _tracker.createInstance<Class_patternContext>(_ctx, getState());
  enterRule(_localctx, 166, Python3Parser::RuleClass_pattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1047);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1017);
      name_or_attr();
      setState(1018);
      match(Python3Parser::OPEN_PAREN);
      setState(1019);
      match(Python3Parser::CLOSE_PAREN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1021);
      name_or_attr();
      setState(1022);
      match(Python3Parser::OPEN_PAREN);
      setState(1023);
      positional_patterns();
      setState(1025);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(1024);
        match(Python3Parser::COMMA);
      }
      setState(1027);
      match(Python3Parser::CLOSE_PAREN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1029);
      name_or_attr();
      setState(1030);
      match(Python3Parser::OPEN_PAREN);
      setState(1031);
      keyword_patterns();
      setState(1033);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(1032);
        match(Python3Parser::COMMA);
      }
      setState(1035);
      match(Python3Parser::CLOSE_PAREN);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1037);
      name_or_attr();
      setState(1038);
      match(Python3Parser::OPEN_PAREN);
      setState(1039);
      positional_patterns();
      setState(1040);
      match(Python3Parser::COMMA);
      setState(1041);
      keyword_patterns();
      setState(1043);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COMMA) {
        setState(1042);
        match(Python3Parser::COMMA);
      }
      setState(1045);
      match(Python3Parser::CLOSE_PAREN);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Positional_patternsContext ------------------------------------------------------------------

Python3Parser::Positional_patternsContext::Positional_patternsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::PatternContext *> Python3Parser::Positional_patternsContext::pattern() {
  return getRuleContexts<Python3Parser::PatternContext>();
}

Python3Parser::PatternContext* Python3Parser::Positional_patternsContext::pattern(size_t i) {
  return getRuleContext<Python3Parser::PatternContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Positional_patternsContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Positional_patternsContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Positional_patternsContext::getRuleIndex() const {
  return Python3Parser::RulePositional_patterns;
}

void Python3Parser::Positional_patternsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPositional_patterns(this);
}

void Python3Parser::Positional_patternsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPositional_patterns(this);
}


std::any Python3Parser::Positional_patternsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitPositional_patterns(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Positional_patternsContext* Python3Parser::positional_patterns() {
  Positional_patternsContext *_localctx = _tracker.createInstance<Positional_patternsContext>(_ctx, getState());
  enterRule(_localctx, 168, Python3Parser::RulePositional_patterns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1049);
    pattern();
    setState(1054);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1050);
        match(Python3Parser::COMMA);
        setState(1051);
        pattern(); 
      }
      setState(1056);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_patternsContext ------------------------------------------------------------------

Python3Parser::Keyword_patternsContext::Keyword_patternsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Keyword_patternContext *> Python3Parser::Keyword_patternsContext::keyword_pattern() {
  return getRuleContexts<Python3Parser::Keyword_patternContext>();
}

Python3Parser::Keyword_patternContext* Python3Parser::Keyword_patternsContext::keyword_pattern(size_t i) {
  return getRuleContext<Python3Parser::Keyword_patternContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Keyword_patternsContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Keyword_patternsContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Keyword_patternsContext::getRuleIndex() const {
  return Python3Parser::RuleKeyword_patterns;
}

void Python3Parser::Keyword_patternsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_patterns(this);
}

void Python3Parser::Keyword_patternsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_patterns(this);
}


std::any Python3Parser::Keyword_patternsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_patterns(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Keyword_patternsContext* Python3Parser::keyword_patterns() {
  Keyword_patternsContext *_localctx = _tracker.createInstance<Keyword_patternsContext>(_ctx, getState());
  enterRule(_localctx, 170, Python3Parser::RuleKeyword_patterns);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1057);
    keyword_pattern();
    setState(1062);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1058);
        match(Python3Parser::COMMA);
        setState(1059);
        keyword_pattern(); 
      }
      setState(1064);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Keyword_patternContext ------------------------------------------------------------------

Python3Parser::Keyword_patternContext::Keyword_patternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::NameContext* Python3Parser::Keyword_patternContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}

tree::TerminalNode* Python3Parser::Keyword_patternContext::ASSIGN() {
  return getToken(Python3Parser::ASSIGN, 0);
}

Python3Parser::PatternContext* Python3Parser::Keyword_patternContext::pattern() {
  return getRuleContext<Python3Parser::PatternContext>(0);
}


size_t Python3Parser::Keyword_patternContext::getRuleIndex() const {
  return Python3Parser::RuleKeyword_pattern;
}

void Python3Parser::Keyword_patternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword_pattern(this);
}

void Python3Parser::Keyword_patternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword_pattern(this);
}


std::any Python3Parser::Keyword_patternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitKeyword_pattern(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Keyword_patternContext* Python3Parser::keyword_pattern() {
  Keyword_patternContext *_localctx = _tracker.createInstance<Keyword_patternContext>(_ctx, getState());
  enterRule(_localctx, 172, Python3Parser::RuleKeyword_pattern);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1065);
    name();
    setState(1066);
    match(Python3Parser::ASSIGN);
    setState(1067);
    pattern();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestContext ------------------------------------------------------------------

Python3Parser::TestContext::TestContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Or_testContext *> Python3Parser::TestContext::or_test() {
  return getRuleContexts<Python3Parser::Or_testContext>();
}

Python3Parser::Or_testContext* Python3Parser::TestContext::or_test(size_t i) {
  return getRuleContext<Python3Parser::Or_testContext>(i);
}

tree::TerminalNode* Python3Parser::TestContext::IF() {
  return getToken(Python3Parser::IF, 0);
}

tree::TerminalNode* Python3Parser::TestContext::ELSE() {
  return getToken(Python3Parser::ELSE, 0);
}

Python3Parser::TestContext* Python3Parser::TestContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

Python3Parser::LambdefContext* Python3Parser::TestContext::lambdef() {
  return getRuleContext<Python3Parser::LambdefContext>(0);
}


size_t Python3Parser::TestContext::getRuleIndex() const {
  return Python3Parser::RuleTest;
}

void Python3Parser::TestContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTest(this);
}

void Python3Parser::TestContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTest(this);
}


std::any Python3Parser::TestContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTest(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::TestContext* Python3Parser::test() {
  TestContext *_localctx = _tracker.createInstance<TestContext>(_ctx, getState());
  enterRule(_localctx, 174, Python3Parser::RuleTest);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1078);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(1069);
        or_test();
        setState(1075);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::IF) {
          setState(1070);
          match(Python3Parser::IF);
          setState(1071);
          or_test();
          setState(1072);
          match(Python3Parser::ELSE);
          setState(1073);
          test();
        }
        break;
      }

      case Python3Parser::LAMBDA: {
        enterOuterAlt(_localctx, 2);
        setState(1077);
        lambdef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Test_nocondContext ------------------------------------------------------------------

Python3Parser::Test_nocondContext::Test_nocondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Or_testContext* Python3Parser::Test_nocondContext::or_test() {
  return getRuleContext<Python3Parser::Or_testContext>(0);
}

Python3Parser::Lambdef_nocondContext* Python3Parser::Test_nocondContext::lambdef_nocond() {
  return getRuleContext<Python3Parser::Lambdef_nocondContext>(0);
}


size_t Python3Parser::Test_nocondContext::getRuleIndex() const {
  return Python3Parser::RuleTest_nocond;
}

void Python3Parser::Test_nocondContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTest_nocond(this);
}

void Python3Parser::Test_nocondContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTest_nocond(this);
}


std::any Python3Parser::Test_nocondContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTest_nocond(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Test_nocondContext* Python3Parser::test_nocond() {
  Test_nocondContext *_localctx = _tracker.createInstance<Test_nocondContext>(_ctx, getState());
  enterRule(_localctx, 176, Python3Parser::RuleTest_nocond);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1082);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(1080);
        or_test();
        break;
      }

      case Python3Parser::LAMBDA: {
        enterOuterAlt(_localctx, 2);
        setState(1081);
        lambdef_nocond();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdefContext ------------------------------------------------------------------

Python3Parser::LambdefContext::LambdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::LambdefContext::LAMBDA() {
  return getToken(Python3Parser::LAMBDA, 0);
}

tree::TerminalNode* Python3Parser::LambdefContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::TestContext* Python3Parser::LambdefContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

Python3Parser::VarargslistContext* Python3Parser::LambdefContext::varargslist() {
  return getRuleContext<Python3Parser::VarargslistContext>(0);
}


size_t Python3Parser::LambdefContext::getRuleIndex() const {
  return Python3Parser::RuleLambdef;
}

void Python3Parser::LambdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdef(this);
}

void Python3Parser::LambdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdef(this);
}


std::any Python3Parser::LambdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitLambdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::LambdefContext* Python3Parser::lambdef() {
  LambdefContext *_localctx = _tracker.createInstance<LambdefContext>(_ctx, getState());
  enterRule(_localctx, 178, Python3Parser::RuleLambdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1084);
    match(Python3Parser::LAMBDA);
    setState(1086);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4683779897422774272) != 0)) {
      setState(1085);
      varargslist();
    }
    setState(1088);
    match(Python3Parser::COLON);
    setState(1089);
    test();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lambdef_nocondContext ------------------------------------------------------------------

Python3Parser::Lambdef_nocondContext::Lambdef_nocondContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Lambdef_nocondContext::LAMBDA() {
  return getToken(Python3Parser::LAMBDA, 0);
}

tree::TerminalNode* Python3Parser::Lambdef_nocondContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::Test_nocondContext* Python3Parser::Lambdef_nocondContext::test_nocond() {
  return getRuleContext<Python3Parser::Test_nocondContext>(0);
}

Python3Parser::VarargslistContext* Python3Parser::Lambdef_nocondContext::varargslist() {
  return getRuleContext<Python3Parser::VarargslistContext>(0);
}


size_t Python3Parser::Lambdef_nocondContext::getRuleIndex() const {
  return Python3Parser::RuleLambdef_nocond;
}

void Python3Parser::Lambdef_nocondContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdef_nocond(this);
}

void Python3Parser::Lambdef_nocondContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdef_nocond(this);
}


std::any Python3Parser::Lambdef_nocondContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitLambdef_nocond(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Lambdef_nocondContext* Python3Parser::lambdef_nocond() {
  Lambdef_nocondContext *_localctx = _tracker.createInstance<Lambdef_nocondContext>(_ctx, getState());
  enterRule(_localctx, 180, Python3Parser::RuleLambdef_nocond);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1091);
    match(Python3Parser::LAMBDA);
    setState(1093);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4683779897422774272) != 0)) {
      setState(1092);
      varargslist();
    }
    setState(1095);
    match(Python3Parser::COLON);
    setState(1096);
    test_nocond();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Or_testContext ------------------------------------------------------------------

Python3Parser::Or_testContext::Or_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::And_testContext *> Python3Parser::Or_testContext::and_test() {
  return getRuleContexts<Python3Parser::And_testContext>();
}

Python3Parser::And_testContext* Python3Parser::Or_testContext::and_test(size_t i) {
  return getRuleContext<Python3Parser::And_testContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::Or_testContext::OR() {
  return getTokens(Python3Parser::OR);
}

tree::TerminalNode* Python3Parser::Or_testContext::OR(size_t i) {
  return getToken(Python3Parser::OR, i);
}


size_t Python3Parser::Or_testContext::getRuleIndex() const {
  return Python3Parser::RuleOr_test;
}

void Python3Parser::Or_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOr_test(this);
}

void Python3Parser::Or_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOr_test(this);
}


std::any Python3Parser::Or_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitOr_test(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Or_testContext* Python3Parser::or_test() {
  Or_testContext *_localctx = _tracker.createInstance<Or_testContext>(_ctx, getState());
  enterRule(_localctx, 182, Python3Parser::RuleOr_test);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1098);
    and_test();
    setState(1103);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::OR) {
      setState(1099);
      match(Python3Parser::OR);
      setState(1100);
      and_test();
      setState(1105);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- And_testContext ------------------------------------------------------------------

Python3Parser::And_testContext::And_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Not_testContext *> Python3Parser::And_testContext::not_test() {
  return getRuleContexts<Python3Parser::Not_testContext>();
}

Python3Parser::Not_testContext* Python3Parser::And_testContext::not_test(size_t i) {
  return getRuleContext<Python3Parser::Not_testContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::And_testContext::AND() {
  return getTokens(Python3Parser::AND);
}

tree::TerminalNode* Python3Parser::And_testContext::AND(size_t i) {
  return getToken(Python3Parser::AND, i);
}


size_t Python3Parser::And_testContext::getRuleIndex() const {
  return Python3Parser::RuleAnd_test;
}

void Python3Parser::And_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnd_test(this);
}

void Python3Parser::And_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnd_test(this);
}


std::any Python3Parser::And_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAnd_test(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::And_testContext* Python3Parser::and_test() {
  And_testContext *_localctx = _tracker.createInstance<And_testContext>(_ctx, getState());
  enterRule(_localctx, 184, Python3Parser::RuleAnd_test);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1106);
    not_test();
    setState(1111);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == Python3Parser::AND) {
      setState(1107);
      match(Python3Parser::AND);
      setState(1108);
      not_test();
      setState(1113);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Not_testContext ------------------------------------------------------------------

Python3Parser::Not_testContext::Not_testContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Not_testContext::NOT() {
  return getToken(Python3Parser::NOT, 0);
}

Python3Parser::Not_testContext* Python3Parser::Not_testContext::not_test() {
  return getRuleContext<Python3Parser::Not_testContext>(0);
}

Python3Parser::ComparisonContext* Python3Parser::Not_testContext::comparison() {
  return getRuleContext<Python3Parser::ComparisonContext>(0);
}


size_t Python3Parser::Not_testContext::getRuleIndex() const {
  return Python3Parser::RuleNot_test;
}

void Python3Parser::Not_testContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNot_test(this);
}

void Python3Parser::Not_testContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNot_test(this);
}


std::any Python3Parser::Not_testContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitNot_test(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Not_testContext* Python3Parser::not_test() {
  Not_testContext *_localctx = _tracker.createInstance<Not_testContext>(_ctx, getState());
  enterRule(_localctx, 186, Python3Parser::RuleNot_test);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1117);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::NOT: {
        enterOuterAlt(_localctx, 1);
        setState(1114);
        match(Python3Parser::NOT);
        setState(1115);
        not_test();
        break;
      }

      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(1116);
        comparison();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonContext ------------------------------------------------------------------

Python3Parser::ComparisonContext::ComparisonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::ExprContext *> Python3Parser::ComparisonContext::expr() {
  return getRuleContexts<Python3Parser::ExprContext>();
}

Python3Parser::ExprContext* Python3Parser::ComparisonContext::expr(size_t i) {
  return getRuleContext<Python3Parser::ExprContext>(i);
}

std::vector<Python3Parser::Comp_opContext *> Python3Parser::ComparisonContext::comp_op() {
  return getRuleContexts<Python3Parser::Comp_opContext>();
}

Python3Parser::Comp_opContext* Python3Parser::ComparisonContext::comp_op(size_t i) {
  return getRuleContext<Python3Parser::Comp_opContext>(i);
}


size_t Python3Parser::ComparisonContext::getRuleIndex() const {
  return Python3Parser::RuleComparison;
}

void Python3Parser::ComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparison(this);
}

void Python3Parser::ComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparison(this);
}


std::any Python3Parser::ComparisonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComparison(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ComparisonContext* Python3Parser::comparison() {
  ComparisonContext *_localctx = _tracker.createInstance<ComparisonContext>(_ctx, getState());
  enterRule(_localctx, 188, Python3Parser::RuleComparison);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1119);
    expr(0);
    setState(1125);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1120);
        comp_op();
        setState(1121);
        expr(0); 
      }
      setState(1127);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_opContext ------------------------------------------------------------------

Python3Parser::Comp_opContext::Comp_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Comp_opContext::LESS_THAN() {
  return getToken(Python3Parser::LESS_THAN, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::GREATER_THAN() {
  return getToken(Python3Parser::GREATER_THAN, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::EQUALS() {
  return getToken(Python3Parser::EQUALS, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::GT_EQ() {
  return getToken(Python3Parser::GT_EQ, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::LT_EQ() {
  return getToken(Python3Parser::LT_EQ, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::NOT_EQ_1() {
  return getToken(Python3Parser::NOT_EQ_1, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::NOT_EQ_2() {
  return getToken(Python3Parser::NOT_EQ_2, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::IN() {
  return getToken(Python3Parser::IN, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::NOT() {
  return getToken(Python3Parser::NOT, 0);
}

tree::TerminalNode* Python3Parser::Comp_opContext::IS() {
  return getToken(Python3Parser::IS, 0);
}


size_t Python3Parser::Comp_opContext::getRuleIndex() const {
  return Python3Parser::RuleComp_op;
}

void Python3Parser::Comp_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_op(this);
}

void Python3Parser::Comp_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_op(this);
}


std::any Python3Parser::Comp_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComp_op(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Comp_opContext* Python3Parser::comp_op() {
  Comp_opContext *_localctx = _tracker.createInstance<Comp_opContext>(_ctx, getState());
  enterRule(_localctx, 190, Python3Parser::RuleComp_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1141);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1128);
      match(Python3Parser::LESS_THAN);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1129);
      match(Python3Parser::GREATER_THAN);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1130);
      match(Python3Parser::EQUALS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1131);
      match(Python3Parser::GT_EQ);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1132);
      match(Python3Parser::LT_EQ);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1133);
      match(Python3Parser::NOT_EQ_1);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1134);
      match(Python3Parser::NOT_EQ_2);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1135);
      match(Python3Parser::IN);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1136);
      match(Python3Parser::NOT);
      setState(1137);
      match(Python3Parser::IN);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1138);
      match(Python3Parser::IS);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1139);
      match(Python3Parser::IS);
      setState(1140);
      match(Python3Parser::NOT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Star_exprContext ------------------------------------------------------------------

Python3Parser::Star_exprContext::Star_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Star_exprContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

Python3Parser::ExprContext* Python3Parser::Star_exprContext::expr() {
  return getRuleContext<Python3Parser::ExprContext>(0);
}


size_t Python3Parser::Star_exprContext::getRuleIndex() const {
  return Python3Parser::RuleStar_expr;
}

void Python3Parser::Star_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStar_expr(this);
}

void Python3Parser::Star_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStar_expr(this);
}


std::any Python3Parser::Star_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStar_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Star_exprContext* Python3Parser::star_expr() {
  Star_exprContext *_localctx = _tracker.createInstance<Star_exprContext>(_ctx, getState());
  enterRule(_localctx, 192, Python3Parser::RuleStar_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1143);
    match(Python3Parser::STAR);
    setState(1144);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

Python3Parser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Atom_exprContext* Python3Parser::ExprContext::atom_expr() {
  return getRuleContext<Python3Parser::Atom_exprContext>(0);
}

std::vector<Python3Parser::ExprContext *> Python3Parser::ExprContext::expr() {
  return getRuleContexts<Python3Parser::ExprContext>();
}

Python3Parser::ExprContext* Python3Parser::ExprContext::expr(size_t i) {
  return getRuleContext<Python3Parser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::ExprContext::ADD() {
  return getTokens(Python3Parser::ADD);
}

tree::TerminalNode* Python3Parser::ExprContext::ADD(size_t i) {
  return getToken(Python3Parser::ADD, i);
}

std::vector<tree::TerminalNode *> Python3Parser::ExprContext::MINUS() {
  return getTokens(Python3Parser::MINUS);
}

tree::TerminalNode* Python3Parser::ExprContext::MINUS(size_t i) {
  return getToken(Python3Parser::MINUS, i);
}

std::vector<tree::TerminalNode *> Python3Parser::ExprContext::NOT_OP() {
  return getTokens(Python3Parser::NOT_OP);
}

tree::TerminalNode* Python3Parser::ExprContext::NOT_OP(size_t i) {
  return getToken(Python3Parser::NOT_OP, i);
}

tree::TerminalNode* Python3Parser::ExprContext::POWER() {
  return getToken(Python3Parser::POWER, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::AT() {
  return getToken(Python3Parser::AT, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::DIV() {
  return getToken(Python3Parser::DIV, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::MOD() {
  return getToken(Python3Parser::MOD, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::IDIV() {
  return getToken(Python3Parser::IDIV, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::LEFT_SHIFT() {
  return getToken(Python3Parser::LEFT_SHIFT, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::RIGHT_SHIFT() {
  return getToken(Python3Parser::RIGHT_SHIFT, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::AND_OP() {
  return getToken(Python3Parser::AND_OP, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::XOR() {
  return getToken(Python3Parser::XOR, 0);
}

tree::TerminalNode* Python3Parser::ExprContext::OR_OP() {
  return getToken(Python3Parser::OR_OP, 0);
}


size_t Python3Parser::ExprContext::getRuleIndex() const {
  return Python3Parser::RuleExpr;
}

void Python3Parser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void Python3Parser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


std::any Python3Parser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


Python3Parser::ExprContext* Python3Parser::expr() {
   return expr(0);
}

Python3Parser::ExprContext* Python3Parser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  Python3Parser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  Python3Parser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 194;
  enterRecursionRule(_localctx, 194, Python3Parser::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1154);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::OPEN_BRACE: {
        setState(1147);
        atom_expr();
        break;
      }

      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP: {
        setState(1149); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1148);
                  _la = _input->LA(1);
                  if (!(((((_la - 71) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 71)) & 35) != 0))) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1151); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(1153);
        expr(7);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(1179);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1177);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1156);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1157);
          match(Python3Parser::POWER);
          setState(1158);
          expr(9);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1159);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(1160);
          _la = _input->LA(1);
          if (!(((((_la - 56) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 56)) & 1074659329) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1161);
          expr(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1162);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(1163);
          _la = _input->LA(1);
          if (!(_la == Python3Parser::ADD

          || _la == Python3Parser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1164);
          expr(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1165);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1166);
          _la = _input->LA(1);
          if (!(_la == Python3Parser::LEFT_SHIFT

          || _la == Python3Parser::RIGHT_SHIFT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1167);
          expr(5);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1168);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1169);
          match(Python3Parser::AND_OP);
          setState(1170);
          expr(4);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1171);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1172);
          match(Python3Parser::XOR);
          setState(1173);
          expr(3);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1174);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(1175);
          match(Python3Parser::OR_OP);
          setState(1176);
          expr(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(1181);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Atom_exprContext ------------------------------------------------------------------

Python3Parser::Atom_exprContext::Atom_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::AtomContext* Python3Parser::Atom_exprContext::atom() {
  return getRuleContext<Python3Parser::AtomContext>(0);
}

tree::TerminalNode* Python3Parser::Atom_exprContext::AWAIT() {
  return getToken(Python3Parser::AWAIT, 0);
}

std::vector<Python3Parser::TrailerContext *> Python3Parser::Atom_exprContext::trailer() {
  return getRuleContexts<Python3Parser::TrailerContext>();
}

Python3Parser::TrailerContext* Python3Parser::Atom_exprContext::trailer(size_t i) {
  return getRuleContext<Python3Parser::TrailerContext>(i);
}


size_t Python3Parser::Atom_exprContext::getRuleIndex() const {
  return Python3Parser::RuleAtom_expr;
}

void Python3Parser::Atom_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_expr(this);
}

void Python3Parser::Atom_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_expr(this);
}


std::any Python3Parser::Atom_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAtom_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Atom_exprContext* Python3Parser::atom_expr() {
  Atom_exprContext *_localctx = _tracker.createInstance<Atom_exprContext>(_ctx, getState());
  enterRule(_localctx, 196, Python3Parser::RuleAtom_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1183);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::AWAIT) {
      setState(1182);
      match(Python3Parser::AWAIT);
    }
    setState(1185);
    atom();
    setState(1189);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1186);
        trailer(); 
      }
      setState(1191);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

Python3Parser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::AtomContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::Yield_exprContext* Python3Parser::AtomContext::yield_expr() {
  return getRuleContext<Python3Parser::Yield_exprContext>(0);
}

Python3Parser::Testlist_compContext* Python3Parser::AtomContext::testlist_comp() {
  return getRuleContext<Python3Parser::Testlist_compContext>(0);
}

tree::TerminalNode* Python3Parser::AtomContext::OPEN_BRACK() {
  return getToken(Python3Parser::OPEN_BRACK, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::CLOSE_BRACK() {
  return getToken(Python3Parser::CLOSE_BRACK, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::OPEN_BRACE() {
  return getToken(Python3Parser::OPEN_BRACE, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::CLOSE_BRACE() {
  return getToken(Python3Parser::CLOSE_BRACE, 0);
}

Python3Parser::DictorsetmakerContext* Python3Parser::AtomContext::dictorsetmaker() {
  return getRuleContext<Python3Parser::DictorsetmakerContext>(0);
}

Python3Parser::NameContext* Python3Parser::AtomContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}

tree::TerminalNode* Python3Parser::AtomContext::NUMBER() {
  return getToken(Python3Parser::NUMBER, 0);
}

std::vector<tree::TerminalNode *> Python3Parser::AtomContext::STRING() {
  return getTokens(Python3Parser::STRING);
}

tree::TerminalNode* Python3Parser::AtomContext::STRING(size_t i) {
  return getToken(Python3Parser::STRING, i);
}

tree::TerminalNode* Python3Parser::AtomContext::ELLIPSIS() {
  return getToken(Python3Parser::ELLIPSIS, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::NONE() {
  return getToken(Python3Parser::NONE, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::TRUE() {
  return getToken(Python3Parser::TRUE, 0);
}

tree::TerminalNode* Python3Parser::AtomContext::FALSE() {
  return getToken(Python3Parser::FALSE, 0);
}


size_t Python3Parser::AtomContext::getRuleIndex() const {
  return Python3Parser::RuleAtom;
}

void Python3Parser::AtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom(this);
}

void Python3Parser::AtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom(this);
}


std::any Python3Parser::AtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitAtom(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::AtomContext* Python3Parser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 198, Python3Parser::RuleAtom);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1219);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(1192);
        match(Python3Parser::OPEN_PAREN);
        setState(1195);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case Python3Parser::YIELD: {
            setState(1193);
            yield_expr();
            break;
          }

          case Python3Parser::STRING:
          case Python3Parser::NUMBER:
          case Python3Parser::AWAIT:
          case Python3Parser::FALSE:
          case Python3Parser::LAMBDA:
          case Python3Parser::MATCH:
          case Python3Parser::NONE:
          case Python3Parser::NOT:
          case Python3Parser::TRUE:
          case Python3Parser::UNDERSCORE:
          case Python3Parser::NAME:
          case Python3Parser::ELLIPSIS:
          case Python3Parser::STAR:
          case Python3Parser::OPEN_PAREN:
          case Python3Parser::OPEN_BRACK:
          case Python3Parser::ADD:
          case Python3Parser::MINUS:
          case Python3Parser::NOT_OP:
          case Python3Parser::OPEN_BRACE: {
            setState(1194);
            testlist_comp();
            break;
          }

          case Python3Parser::CLOSE_PAREN: {
            break;
          }

        default:
          break;
        }
        setState(1197);
        match(Python3Parser::CLOSE_PAREN);
        break;
      }

      case Python3Parser::OPEN_BRACK: {
        enterOuterAlt(_localctx, 2);
        setState(1198);
        match(Python3Parser::OPEN_BRACK);
        setState(1200);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 252238150243451928) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 12673) != 0)) {
          setState(1199);
          testlist_comp();
        }
        setState(1202);
        match(Python3Parser::CLOSE_BRACK);
        break;
      }

      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 3);
        setState(1203);
        match(Python3Parser::OPEN_BRACE);
        setState(1205);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 4863924168670839832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 12673) != 0)) {
          setState(1204);
          dictorsetmaker();
        }
        setState(1207);
        match(Python3Parser::CLOSE_BRACE);
        break;
      }

      case Python3Parser::MATCH:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME: {
        enterOuterAlt(_localctx, 4);
        setState(1208);
        name();
        break;
      }

      case Python3Parser::NUMBER: {
        enterOuterAlt(_localctx, 5);
        setState(1209);
        match(Python3Parser::NUMBER);
        break;
      }

      case Python3Parser::STRING: {
        enterOuterAlt(_localctx, 6);
        setState(1211); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1210);
                  match(Python3Parser::STRING);
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1213); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case Python3Parser::ELLIPSIS: {
        enterOuterAlt(_localctx, 7);
        setState(1215);
        match(Python3Parser::ELLIPSIS);
        break;
      }

      case Python3Parser::NONE: {
        enterOuterAlt(_localctx, 8);
        setState(1216);
        match(Python3Parser::NONE);
        break;
      }

      case Python3Parser::TRUE: {
        enterOuterAlt(_localctx, 9);
        setState(1217);
        match(Python3Parser::TRUE);
        break;
      }

      case Python3Parser::FALSE: {
        enterOuterAlt(_localctx, 10);
        setState(1218);
        match(Python3Parser::FALSE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

Python3Parser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::NameContext::NAME() {
  return getToken(Python3Parser::NAME, 0);
}

tree::TerminalNode* Python3Parser::NameContext::UNDERSCORE() {
  return getToken(Python3Parser::UNDERSCORE, 0);
}

tree::TerminalNode* Python3Parser::NameContext::MATCH() {
  return getToken(Python3Parser::MATCH, 0);
}


size_t Python3Parser::NameContext::getRuleIndex() const {
  return Python3Parser::RuleName;
}

void Python3Parser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void Python3Parser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any Python3Parser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::NameContext* Python3Parser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 200, Python3Parser::RuleName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1221);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 36284957458432) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Testlist_compContext ------------------------------------------------------------------

Python3Parser::Testlist_compContext::Testlist_compContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::Testlist_compContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::Testlist_compContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<Python3Parser::Star_exprContext *> Python3Parser::Testlist_compContext::star_expr() {
  return getRuleContexts<Python3Parser::Star_exprContext>();
}

Python3Parser::Star_exprContext* Python3Parser::Testlist_compContext::star_expr(size_t i) {
  return getRuleContext<Python3Parser::Star_exprContext>(i);
}

Python3Parser::Comp_forContext* Python3Parser::Testlist_compContext::comp_for() {
  return getRuleContext<Python3Parser::Comp_forContext>(0);
}

std::vector<tree::TerminalNode *> Python3Parser::Testlist_compContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::Testlist_compContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::Testlist_compContext::getRuleIndex() const {
  return Python3Parser::RuleTestlist_comp;
}

void Python3Parser::Testlist_compContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist_comp(this);
}

void Python3Parser::Testlist_compContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist_comp(this);
}


std::any Python3Parser::Testlist_compContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTestlist_comp(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Testlist_compContext* Python3Parser::testlist_comp() {
  Testlist_compContext *_localctx = _tracker.createInstance<Testlist_compContext>(_ctx, getState());
  enterRule(_localctx, 202, Python3Parser::RuleTestlist_comp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1225);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        setState(1223);
        test();
        break;
      }

      case Python3Parser::STAR: {
        setState(1224);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1241);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::ASYNC:
      case Python3Parser::FOR: {
        setState(1227);
        comp_for();
        break;
      }

      case Python3Parser::CLOSE_PAREN:
      case Python3Parser::COMMA:
      case Python3Parser::CLOSE_BRACK: {
        setState(1235);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1228);
            match(Python3Parser::COMMA);
            setState(1231);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case Python3Parser::STRING:
              case Python3Parser::NUMBER:
              case Python3Parser::AWAIT:
              case Python3Parser::FALSE:
              case Python3Parser::LAMBDA:
              case Python3Parser::MATCH:
              case Python3Parser::NONE:
              case Python3Parser::NOT:
              case Python3Parser::TRUE:
              case Python3Parser::UNDERSCORE:
              case Python3Parser::NAME:
              case Python3Parser::ELLIPSIS:
              case Python3Parser::OPEN_PAREN:
              case Python3Parser::OPEN_BRACK:
              case Python3Parser::ADD:
              case Python3Parser::MINUS:
              case Python3Parser::NOT_OP:
              case Python3Parser::OPEN_BRACE: {
                setState(1229);
                test();
                break;
              }

              case Python3Parser::STAR: {
                setState(1230);
                star_expr();
                break;
              }

            default:
              throw NoViableAltException(this);
            } 
          }
          setState(1237);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx);
        }
        setState(1239);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == Python3Parser::COMMA) {
          setState(1238);
          match(Python3Parser::COMMA);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailerContext ------------------------------------------------------------------

Python3Parser::TrailerContext::TrailerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::TrailerContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::TrailerContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::ArglistContext* Python3Parser::TrailerContext::arglist() {
  return getRuleContext<Python3Parser::ArglistContext>(0);
}

tree::TerminalNode* Python3Parser::TrailerContext::OPEN_BRACK() {
  return getToken(Python3Parser::OPEN_BRACK, 0);
}

Python3Parser::SubscriptlistContext* Python3Parser::TrailerContext::subscriptlist() {
  return getRuleContext<Python3Parser::SubscriptlistContext>(0);
}

tree::TerminalNode* Python3Parser::TrailerContext::CLOSE_BRACK() {
  return getToken(Python3Parser::CLOSE_BRACK, 0);
}

tree::TerminalNode* Python3Parser::TrailerContext::DOT() {
  return getToken(Python3Parser::DOT, 0);
}

Python3Parser::NameContext* Python3Parser::TrailerContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::TrailerContext::getRuleIndex() const {
  return Python3Parser::RuleTrailer;
}

void Python3Parser::TrailerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailer(this);
}

void Python3Parser::TrailerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailer(this);
}


std::any Python3Parser::TrailerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTrailer(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::TrailerContext* Python3Parser::trailer() {
  TrailerContext *_localctx = _tracker.createInstance<TrailerContext>(_ctx, getState());
  enterRule(_localctx, 204, Python3Parser::RuleTrailer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1254);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::OPEN_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(1243);
        match(Python3Parser::OPEN_PAREN);
        setState(1245);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 4863924168670839832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 12673) != 0)) {
          setState(1244);
          arglist();
        }
        setState(1247);
        match(Python3Parser::CLOSE_PAREN);
        break;
      }

      case Python3Parser::OPEN_BRACK: {
        enterOuterAlt(_localctx, 2);
        setState(1248);
        match(Python3Parser::OPEN_BRACK);
        setState(1249);
        subscriptlist();
        setState(1250);
        match(Python3Parser::CLOSE_BRACK);
        break;
      }

      case Python3Parser::DOT: {
        enterOuterAlt(_localctx, 3);
        setState(1252);
        match(Python3Parser::DOT);
        setState(1253);
        name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubscriptlistContext ------------------------------------------------------------------

Python3Parser::SubscriptlistContext::SubscriptlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::Subscript_Context *> Python3Parser::SubscriptlistContext::subscript_() {
  return getRuleContexts<Python3Parser::Subscript_Context>();
}

Python3Parser::Subscript_Context* Python3Parser::SubscriptlistContext::subscript_(size_t i) {
  return getRuleContext<Python3Parser::Subscript_Context>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::SubscriptlistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::SubscriptlistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::SubscriptlistContext::getRuleIndex() const {
  return Python3Parser::RuleSubscriptlist;
}

void Python3Parser::SubscriptlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscriptlist(this);
}

void Python3Parser::SubscriptlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscriptlist(this);
}


std::any Python3Parser::SubscriptlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSubscriptlist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::SubscriptlistContext* Python3Parser::subscriptlist() {
  SubscriptlistContext *_localctx = _tracker.createInstance<SubscriptlistContext>(_ctx, getState());
  enterRule(_localctx, 206, Python3Parser::RuleSubscriptlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1256);
    subscript_();
    setState(1261);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1257);
        match(Python3Parser::COMMA);
        setState(1258);
        subscript_(); 
      }
      setState(1263);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx);
    }
    setState(1265);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(1264);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Subscript_Context ------------------------------------------------------------------

Python3Parser::Subscript_Context::Subscript_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::Subscript_Context::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::Subscript_Context::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

tree::TerminalNode* Python3Parser::Subscript_Context::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::SliceopContext* Python3Parser::Subscript_Context::sliceop() {
  return getRuleContext<Python3Parser::SliceopContext>(0);
}


size_t Python3Parser::Subscript_Context::getRuleIndex() const {
  return Python3Parser::RuleSubscript_;
}

void Python3Parser::Subscript_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubscript_(this);
}

void Python3Parser::Subscript_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubscript_(this);
}


std::any Python3Parser::Subscript_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSubscript_(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Subscript_Context* Python3Parser::subscript_() {
  Subscript_Context *_localctx = _tracker.createInstance<Subscript_Context>(_ctx, getState());
  enterRule(_localctx, 208, Python3Parser::RuleSubscript_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1278);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1267);
      test();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1269);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 12673) != 0)) {
        setState(1268);
        test();
      }
      setState(1271);
      match(Python3Parser::COLON);
      setState(1273);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 12673) != 0)) {
        setState(1272);
        test();
      }
      setState(1276);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::COLON) {
        setState(1275);
        sliceop();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SliceopContext ------------------------------------------------------------------

Python3Parser::SliceopContext::SliceopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::SliceopContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::TestContext* Python3Parser::SliceopContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}


size_t Python3Parser::SliceopContext::getRuleIndex() const {
  return Python3Parser::RuleSliceop;
}

void Python3Parser::SliceopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSliceop(this);
}

void Python3Parser::SliceopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSliceop(this);
}


std::any Python3Parser::SliceopContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitSliceop(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::SliceopContext* Python3Parser::sliceop() {
  SliceopContext *_localctx = _tracker.createInstance<SliceopContext>(_ctx, getState());
  enterRule(_localctx, 210, Python3Parser::RuleSliceop);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1280);
    match(Python3Parser::COLON);
    setState(1282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 180180556205523992) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0)) {
      setState(1281);
      test();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprlistContext ------------------------------------------------------------------

Python3Parser::ExprlistContext::ExprlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::ExprContext *> Python3Parser::ExprlistContext::expr() {
  return getRuleContexts<Python3Parser::ExprContext>();
}

Python3Parser::ExprContext* Python3Parser::ExprlistContext::expr(size_t i) {
  return getRuleContext<Python3Parser::ExprContext>(i);
}

std::vector<Python3Parser::Star_exprContext *> Python3Parser::ExprlistContext::star_expr() {
  return getRuleContexts<Python3Parser::Star_exprContext>();
}

Python3Parser::Star_exprContext* Python3Parser::ExprlistContext::star_expr(size_t i) {
  return getRuleContext<Python3Parser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::ExprlistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::ExprlistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::ExprlistContext::getRuleIndex() const {
  return Python3Parser::RuleExprlist;
}

void Python3Parser::ExprlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprlist(this);
}

void Python3Parser::ExprlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprlist(this);
}


std::any Python3Parser::ExprlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitExprlist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ExprlistContext* Python3Parser::exprlist() {
  ExprlistContext *_localctx = _tracker.createInstance<ExprlistContext>(_ctx, getState());
  enterRule(_localctx, 212, Python3Parser::RuleExprlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1286);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        setState(1284);
        expr(0);
        break;
      }

      case Python3Parser::STAR: {
        setState(1285);
        star_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1295);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1288);
        match(Python3Parser::COMMA);
        setState(1291);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case Python3Parser::STRING:
          case Python3Parser::NUMBER:
          case Python3Parser::AWAIT:
          case Python3Parser::FALSE:
          case Python3Parser::MATCH:
          case Python3Parser::NONE:
          case Python3Parser::TRUE:
          case Python3Parser::UNDERSCORE:
          case Python3Parser::NAME:
          case Python3Parser::ELLIPSIS:
          case Python3Parser::OPEN_PAREN:
          case Python3Parser::OPEN_BRACK:
          case Python3Parser::ADD:
          case Python3Parser::MINUS:
          case Python3Parser::NOT_OP:
          case Python3Parser::OPEN_BRACE: {
            setState(1289);
            expr(0);
            break;
          }

          case Python3Parser::STAR: {
            setState(1290);
            star_expr();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(1297);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
    }
    setState(1299);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(1298);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TestlistContext ------------------------------------------------------------------

Python3Parser::TestlistContext::TestlistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::TestlistContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::TestlistContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::TestlistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::TestlistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::TestlistContext::getRuleIndex() const {
  return Python3Parser::RuleTestlist;
}

void Python3Parser::TestlistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTestlist(this);
}

void Python3Parser::TestlistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTestlist(this);
}


std::any Python3Parser::TestlistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitTestlist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::TestlistContext* Python3Parser::testlist() {
  TestlistContext *_localctx = _tracker.createInstance<TestlistContext>(_ctx, getState());
  enterRule(_localctx, 214, Python3Parser::RuleTestlist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1301);
    test();
    setState(1306);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1302);
        match(Python3Parser::COMMA);
        setState(1303);
        test(); 
      }
      setState(1308);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx);
    }
    setState(1310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(1309);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DictorsetmakerContext ------------------------------------------------------------------

Python3Parser::DictorsetmakerContext::DictorsetmakerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::DictorsetmakerContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::DictorsetmakerContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::DictorsetmakerContext::COLON() {
  return getTokens(Python3Parser::COLON);
}

tree::TerminalNode* Python3Parser::DictorsetmakerContext::COLON(size_t i) {
  return getToken(Python3Parser::COLON, i);
}

std::vector<tree::TerminalNode *> Python3Parser::DictorsetmakerContext::POWER() {
  return getTokens(Python3Parser::POWER);
}

tree::TerminalNode* Python3Parser::DictorsetmakerContext::POWER(size_t i) {
  return getToken(Python3Parser::POWER, i);
}

std::vector<Python3Parser::ExprContext *> Python3Parser::DictorsetmakerContext::expr() {
  return getRuleContexts<Python3Parser::ExprContext>();
}

Python3Parser::ExprContext* Python3Parser::DictorsetmakerContext::expr(size_t i) {
  return getRuleContext<Python3Parser::ExprContext>(i);
}

Python3Parser::Comp_forContext* Python3Parser::DictorsetmakerContext::comp_for() {
  return getRuleContext<Python3Parser::Comp_forContext>(0);
}

std::vector<Python3Parser::Star_exprContext *> Python3Parser::DictorsetmakerContext::star_expr() {
  return getRuleContexts<Python3Parser::Star_exprContext>();
}

Python3Parser::Star_exprContext* Python3Parser::DictorsetmakerContext::star_expr(size_t i) {
  return getRuleContext<Python3Parser::Star_exprContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::DictorsetmakerContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::DictorsetmakerContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::DictorsetmakerContext::getRuleIndex() const {
  return Python3Parser::RuleDictorsetmaker;
}

void Python3Parser::DictorsetmakerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDictorsetmaker(this);
}

void Python3Parser::DictorsetmakerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDictorsetmaker(this);
}


std::any Python3Parser::DictorsetmakerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitDictorsetmaker(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::DictorsetmakerContext* Python3Parser::dictorsetmaker() {
  DictorsetmakerContext *_localctx = _tracker.createInstance<DictorsetmakerContext>(_ctx, getState());
  enterRule(_localctx, 216, Python3Parser::RuleDictorsetmaker);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1360);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      setState(1318);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case Python3Parser::STRING:
        case Python3Parser::NUMBER:
        case Python3Parser::AWAIT:
        case Python3Parser::FALSE:
        case Python3Parser::LAMBDA:
        case Python3Parser::MATCH:
        case Python3Parser::NONE:
        case Python3Parser::NOT:
        case Python3Parser::TRUE:
        case Python3Parser::UNDERSCORE:
        case Python3Parser::NAME:
        case Python3Parser::ELLIPSIS:
        case Python3Parser::OPEN_PAREN:
        case Python3Parser::OPEN_BRACK:
        case Python3Parser::ADD:
        case Python3Parser::MINUS:
        case Python3Parser::NOT_OP:
        case Python3Parser::OPEN_BRACE: {
          setState(1312);
          test();
          setState(1313);
          match(Python3Parser::COLON);
          setState(1314);
          test();
          break;
        }

        case Python3Parser::POWER: {
          setState(1316);
          match(Python3Parser::POWER);
          setState(1317);
          expr(0);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1338);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case Python3Parser::ASYNC:
        case Python3Parser::FOR: {
          setState(1320);
          comp_for();
          break;
        }

        case Python3Parser::COMMA:
        case Python3Parser::CLOSE_BRACE: {
          setState(1332);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(1321);
              match(Python3Parser::COMMA);
              setState(1328);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case Python3Parser::STRING:
                case Python3Parser::NUMBER:
                case Python3Parser::AWAIT:
                case Python3Parser::FALSE:
                case Python3Parser::LAMBDA:
                case Python3Parser::MATCH:
                case Python3Parser::NONE:
                case Python3Parser::NOT:
                case Python3Parser::TRUE:
                case Python3Parser::UNDERSCORE:
                case Python3Parser::NAME:
                case Python3Parser::ELLIPSIS:
                case Python3Parser::OPEN_PAREN:
                case Python3Parser::OPEN_BRACK:
                case Python3Parser::ADD:
                case Python3Parser::MINUS:
                case Python3Parser::NOT_OP:
                case Python3Parser::OPEN_BRACE: {
                  setState(1322);
                  test();
                  setState(1323);
                  match(Python3Parser::COLON);
                  setState(1324);
                  test();
                  break;
                }

                case Python3Parser::POWER: {
                  setState(1326);
                  match(Python3Parser::POWER);
                  setState(1327);
                  expr(0);
                  break;
                }

              default:
                throw NoViableAltException(this);
              } 
            }
            setState(1334);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx);
          }
          setState(1336);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == Python3Parser::COMMA) {
            setState(1335);
            match(Python3Parser::COMMA);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(1342);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case Python3Parser::STRING:
        case Python3Parser::NUMBER:
        case Python3Parser::AWAIT:
        case Python3Parser::FALSE:
        case Python3Parser::LAMBDA:
        case Python3Parser::MATCH:
        case Python3Parser::NONE:
        case Python3Parser::NOT:
        case Python3Parser::TRUE:
        case Python3Parser::UNDERSCORE:
        case Python3Parser::NAME:
        case Python3Parser::ELLIPSIS:
        case Python3Parser::OPEN_PAREN:
        case Python3Parser::OPEN_BRACK:
        case Python3Parser::ADD:
        case Python3Parser::MINUS:
        case Python3Parser::NOT_OP:
        case Python3Parser::OPEN_BRACE: {
          setState(1340);
          test();
          break;
        }

        case Python3Parser::STAR: {
          setState(1341);
          star_expr();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1358);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case Python3Parser::ASYNC:
        case Python3Parser::FOR: {
          setState(1344);
          comp_for();
          break;
        }

        case Python3Parser::COMMA:
        case Python3Parser::CLOSE_BRACE: {
          setState(1352);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(1345);
              match(Python3Parser::COMMA);
              setState(1348);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case Python3Parser::STRING:
                case Python3Parser::NUMBER:
                case Python3Parser::AWAIT:
                case Python3Parser::FALSE:
                case Python3Parser::LAMBDA:
                case Python3Parser::MATCH:
                case Python3Parser::NONE:
                case Python3Parser::NOT:
                case Python3Parser::TRUE:
                case Python3Parser::UNDERSCORE:
                case Python3Parser::NAME:
                case Python3Parser::ELLIPSIS:
                case Python3Parser::OPEN_PAREN:
                case Python3Parser::OPEN_BRACK:
                case Python3Parser::ADD:
                case Python3Parser::MINUS:
                case Python3Parser::NOT_OP:
                case Python3Parser::OPEN_BRACE: {
                  setState(1346);
                  test();
                  break;
                }

                case Python3Parser::STAR: {
                  setState(1347);
                  star_expr();
                  break;
                }

              default:
                throw NoViableAltException(this);
              } 
            }
            setState(1354);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx);
          }
          setState(1356);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == Python3Parser::COMMA) {
            setState(1355);
            match(Python3Parser::COMMA);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassdefContext ------------------------------------------------------------------

Python3Parser::ClassdefContext::ClassdefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::ClassdefContext::CLASS() {
  return getToken(Python3Parser::CLASS, 0);
}

Python3Parser::NameContext* Python3Parser::ClassdefContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}

tree::TerminalNode* Python3Parser::ClassdefContext::COLON() {
  return getToken(Python3Parser::COLON, 0);
}

Python3Parser::BlockContext* Python3Parser::ClassdefContext::block() {
  return getRuleContext<Python3Parser::BlockContext>(0);
}

tree::TerminalNode* Python3Parser::ClassdefContext::OPEN_PAREN() {
  return getToken(Python3Parser::OPEN_PAREN, 0);
}

tree::TerminalNode* Python3Parser::ClassdefContext::CLOSE_PAREN() {
  return getToken(Python3Parser::CLOSE_PAREN, 0);
}

Python3Parser::ArglistContext* Python3Parser::ClassdefContext::arglist() {
  return getRuleContext<Python3Parser::ArglistContext>(0);
}


size_t Python3Parser::ClassdefContext::getRuleIndex() const {
  return Python3Parser::RuleClassdef;
}

void Python3Parser::ClassdefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassdef(this);
}

void Python3Parser::ClassdefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassdef(this);
}


std::any Python3Parser::ClassdefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitClassdef(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ClassdefContext* Python3Parser::classdef() {
  ClassdefContext *_localctx = _tracker.createInstance<ClassdefContext>(_ctx, getState());
  enterRule(_localctx, 218, Python3Parser::RuleClassdef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1362);
    match(Python3Parser::CLASS);
    setState(1363);
    name();
    setState(1369);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::OPEN_PAREN) {
      setState(1364);
      match(Python3Parser::OPEN_PAREN);
      setState(1366);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4863924168670839832) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 12673) != 0)) {
        setState(1365);
        arglist();
      }
      setState(1368);
      match(Python3Parser::CLOSE_PAREN);
    }
    setState(1371);
    match(Python3Parser::COLON);
    setState(1372);
    block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArglistContext ------------------------------------------------------------------

Python3Parser::ArglistContext::ArglistContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::ArgumentContext *> Python3Parser::ArglistContext::argument() {
  return getRuleContexts<Python3Parser::ArgumentContext>();
}

Python3Parser::ArgumentContext* Python3Parser::ArglistContext::argument(size_t i) {
  return getRuleContext<Python3Parser::ArgumentContext>(i);
}

std::vector<tree::TerminalNode *> Python3Parser::ArglistContext::COMMA() {
  return getTokens(Python3Parser::COMMA);
}

tree::TerminalNode* Python3Parser::ArglistContext::COMMA(size_t i) {
  return getToken(Python3Parser::COMMA, i);
}


size_t Python3Parser::ArglistContext::getRuleIndex() const {
  return Python3Parser::RuleArglist;
}

void Python3Parser::ArglistContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArglist(this);
}

void Python3Parser::ArglistContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArglist(this);
}


std::any Python3Parser::ArglistContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitArglist(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ArglistContext* Python3Parser::arglist() {
  ArglistContext *_localctx = _tracker.createInstance<ArglistContext>(_ctx, getState());
  enterRule(_localctx, 220, Python3Parser::RuleArglist);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1374);
    argument();
    setState(1379);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1375);
        match(Python3Parser::COMMA);
        setState(1376);
        argument(); 
      }
      setState(1381);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx);
    }
    setState(1383);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::COMMA) {
      setState(1382);
      match(Python3Parser::COMMA);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentContext ------------------------------------------------------------------

Python3Parser::ArgumentContext::ArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<Python3Parser::TestContext *> Python3Parser::ArgumentContext::test() {
  return getRuleContexts<Python3Parser::TestContext>();
}

Python3Parser::TestContext* Python3Parser::ArgumentContext::test(size_t i) {
  return getRuleContext<Python3Parser::TestContext>(i);
}

tree::TerminalNode* Python3Parser::ArgumentContext::ASSIGN() {
  return getToken(Python3Parser::ASSIGN, 0);
}

tree::TerminalNode* Python3Parser::ArgumentContext::POWER() {
  return getToken(Python3Parser::POWER, 0);
}

tree::TerminalNode* Python3Parser::ArgumentContext::STAR() {
  return getToken(Python3Parser::STAR, 0);
}

Python3Parser::Comp_forContext* Python3Parser::ArgumentContext::comp_for() {
  return getRuleContext<Python3Parser::Comp_forContext>(0);
}


size_t Python3Parser::ArgumentContext::getRuleIndex() const {
  return Python3Parser::RuleArgument;
}

void Python3Parser::ArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument(this);
}

void Python3Parser::ArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument(this);
}


std::any Python3Parser::ArgumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitArgument(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::ArgumentContext* Python3Parser::argument() {
  ArgumentContext *_localctx = _tracker.createInstance<ArgumentContext>(_ctx, getState());
  enterRule(_localctx, 222, Python3Parser::RuleArgument);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1397);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
    case 1: {
      setState(1385);
      test();
      setState(1387);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == Python3Parser::ASYNC

      || _la == Python3Parser::FOR) {
        setState(1386);
        comp_for();
      }
      break;
    }

    case 2: {
      setState(1389);
      test();
      setState(1390);
      match(Python3Parser::ASSIGN);
      setState(1391);
      test();
      break;
    }

    case 3: {
      setState(1393);
      match(Python3Parser::POWER);
      setState(1394);
      test();
      break;
    }

    case 4: {
      setState(1395);
      match(Python3Parser::STAR);
      setState(1396);
      test();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_iterContext ------------------------------------------------------------------

Python3Parser::Comp_iterContext::Comp_iterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::Comp_forContext* Python3Parser::Comp_iterContext::comp_for() {
  return getRuleContext<Python3Parser::Comp_forContext>(0);
}

Python3Parser::Comp_ifContext* Python3Parser::Comp_iterContext::comp_if() {
  return getRuleContext<Python3Parser::Comp_ifContext>(0);
}


size_t Python3Parser::Comp_iterContext::getRuleIndex() const {
  return Python3Parser::RuleComp_iter;
}

void Python3Parser::Comp_iterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_iter(this);
}

void Python3Parser::Comp_iterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_iter(this);
}


std::any Python3Parser::Comp_iterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComp_iter(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Comp_iterContext* Python3Parser::comp_iter() {
  Comp_iterContext *_localctx = _tracker.createInstance<Comp_iterContext>(_ctx, getState());
  enterRule(_localctx, 224, Python3Parser::RuleComp_iter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1401);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::ASYNC:
      case Python3Parser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(1399);
        comp_for();
        break;
      }

      case Python3Parser::IF: {
        enterOuterAlt(_localctx, 2);
        setState(1400);
        comp_if();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_forContext ------------------------------------------------------------------

Python3Parser::Comp_forContext::Comp_forContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Comp_forContext::FOR() {
  return getToken(Python3Parser::FOR, 0);
}

Python3Parser::ExprlistContext* Python3Parser::Comp_forContext::exprlist() {
  return getRuleContext<Python3Parser::ExprlistContext>(0);
}

tree::TerminalNode* Python3Parser::Comp_forContext::IN() {
  return getToken(Python3Parser::IN, 0);
}

Python3Parser::Or_testContext* Python3Parser::Comp_forContext::or_test() {
  return getRuleContext<Python3Parser::Or_testContext>(0);
}

tree::TerminalNode* Python3Parser::Comp_forContext::ASYNC() {
  return getToken(Python3Parser::ASYNC, 0);
}

Python3Parser::Comp_iterContext* Python3Parser::Comp_forContext::comp_iter() {
  return getRuleContext<Python3Parser::Comp_iterContext>(0);
}


size_t Python3Parser::Comp_forContext::getRuleIndex() const {
  return Python3Parser::RuleComp_for;
}

void Python3Parser::Comp_forContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_for(this);
}

void Python3Parser::Comp_forContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_for(this);
}


std::any Python3Parser::Comp_forContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComp_for(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Comp_forContext* Python3Parser::comp_for() {
  Comp_forContext *_localctx = _tracker.createInstance<Comp_forContext>(_ctx, getState());
  enterRule(_localctx, 226, Python3Parser::RuleComp_for);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == Python3Parser::ASYNC) {
      setState(1403);
      match(Python3Parser::ASYNC);
    }
    setState(1406);
    match(Python3Parser::FOR);
    setState(1407);
    exprlist();
    setState(1408);
    match(Python3Parser::IN);
    setState(1409);
    or_test();
    setState(1411);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 37749248) != 0)) {
      setState(1410);
      comp_iter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Comp_ifContext ------------------------------------------------------------------

Python3Parser::Comp_ifContext::Comp_ifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Comp_ifContext::IF() {
  return getToken(Python3Parser::IF, 0);
}

Python3Parser::Test_nocondContext* Python3Parser::Comp_ifContext::test_nocond() {
  return getRuleContext<Python3Parser::Test_nocondContext>(0);
}

Python3Parser::Comp_iterContext* Python3Parser::Comp_ifContext::comp_iter() {
  return getRuleContext<Python3Parser::Comp_iterContext>(0);
}


size_t Python3Parser::Comp_ifContext::getRuleIndex() const {
  return Python3Parser::RuleComp_if;
}

void Python3Parser::Comp_ifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComp_if(this);
}

void Python3Parser::Comp_ifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComp_if(this);
}


std::any Python3Parser::Comp_ifContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitComp_if(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Comp_ifContext* Python3Parser::comp_if() {
  Comp_ifContext *_localctx = _tracker.createInstance<Comp_ifContext>(_ctx, getState());
  enterRule(_localctx, 228, Python3Parser::RuleComp_if);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1413);
    match(Python3Parser::IF);
    setState(1414);
    test_nocond();
    setState(1416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 37749248) != 0)) {
      setState(1415);
      comp_iter();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Encoding_declContext ------------------------------------------------------------------

Python3Parser::Encoding_declContext::Encoding_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

Python3Parser::NameContext* Python3Parser::Encoding_declContext::name() {
  return getRuleContext<Python3Parser::NameContext>(0);
}


size_t Python3Parser::Encoding_declContext::getRuleIndex() const {
  return Python3Parser::RuleEncoding_decl;
}

void Python3Parser::Encoding_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEncoding_decl(this);
}

void Python3Parser::Encoding_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEncoding_decl(this);
}


std::any Python3Parser::Encoding_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitEncoding_decl(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Encoding_declContext* Python3Parser::encoding_decl() {
  Encoding_declContext *_localctx = _tracker.createInstance<Encoding_declContext>(_ctx, getState());
  enterRule(_localctx, 230, Python3Parser::RuleEncoding_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1418);
    name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_exprContext ------------------------------------------------------------------

Python3Parser::Yield_exprContext::Yield_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Yield_exprContext::YIELD() {
  return getToken(Python3Parser::YIELD, 0);
}

Python3Parser::Yield_argContext* Python3Parser::Yield_exprContext::yield_arg() {
  return getRuleContext<Python3Parser::Yield_argContext>(0);
}


size_t Python3Parser::Yield_exprContext::getRuleIndex() const {
  return Python3Parser::RuleYield_expr;
}

void Python3Parser::Yield_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_expr(this);
}

void Python3Parser::Yield_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_expr(this);
}


std::any Python3Parser::Yield_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitYield_expr(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Yield_exprContext* Python3Parser::yield_expr() {
  Yield_exprContext *_localctx = _tracker.createInstance<Yield_exprContext>(_ctx, getState());
  enterRule(_localctx, 232, Python3Parser::RuleYield_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1420);
    match(Python3Parser::YIELD);
    setState(1422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 180180556213912600) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 12673) != 0)) {
      setState(1421);
      yield_arg();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Yield_argContext ------------------------------------------------------------------

Python3Parser::Yield_argContext::Yield_argContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* Python3Parser::Yield_argContext::FROM() {
  return getToken(Python3Parser::FROM, 0);
}

Python3Parser::TestContext* Python3Parser::Yield_argContext::test() {
  return getRuleContext<Python3Parser::TestContext>(0);
}

Python3Parser::TestlistContext* Python3Parser::Yield_argContext::testlist() {
  return getRuleContext<Python3Parser::TestlistContext>(0);
}


size_t Python3Parser::Yield_argContext::getRuleIndex() const {
  return Python3Parser::RuleYield_arg;
}

void Python3Parser::Yield_argContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterYield_arg(this);
}

void Python3Parser::Yield_argContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitYield_arg(this);
}


std::any Python3Parser::Yield_argContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitYield_arg(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::Yield_argContext* Python3Parser::yield_arg() {
  Yield_argContext *_localctx = _tracker.createInstance<Yield_argContext>(_ctx, getState());
  enterRule(_localctx, 234, Python3Parser::RuleYield_arg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1427);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case Python3Parser::FROM: {
        enterOuterAlt(_localctx, 1);
        setState(1424);
        match(Python3Parser::FROM);
        setState(1425);
        test();
        break;
      }

      case Python3Parser::STRING:
      case Python3Parser::NUMBER:
      case Python3Parser::AWAIT:
      case Python3Parser::FALSE:
      case Python3Parser::LAMBDA:
      case Python3Parser::MATCH:
      case Python3Parser::NONE:
      case Python3Parser::NOT:
      case Python3Parser::TRUE:
      case Python3Parser::UNDERSCORE:
      case Python3Parser::NAME:
      case Python3Parser::ELLIPSIS:
      case Python3Parser::OPEN_PAREN:
      case Python3Parser::OPEN_BRACK:
      case Python3Parser::ADD:
      case Python3Parser::MINUS:
      case Python3Parser::NOT_OP:
      case Python3Parser::OPEN_BRACE: {
        enterOuterAlt(_localctx, 2);
        setState(1426);
        testlist();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringsContext ------------------------------------------------------------------

Python3Parser::StringsContext::StringsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> Python3Parser::StringsContext::STRING() {
  return getTokens(Python3Parser::STRING);
}

tree::TerminalNode* Python3Parser::StringsContext::STRING(size_t i) {
  return getToken(Python3Parser::STRING, i);
}


size_t Python3Parser::StringsContext::getRuleIndex() const {
  return Python3Parser::RuleStrings;
}

void Python3Parser::StringsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStrings(this);
}

void Python3Parser::StringsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<Python3ParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStrings(this);
}


std::any Python3Parser::StringsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<Python3ParserVisitor*>(visitor))
    return parserVisitor->visitStrings(this);
  else
    return visitor->visitChildren(this);
}

Python3Parser::StringsContext* Python3Parser::strings() {
  StringsContext *_localctx = _tracker.createInstance<StringsContext>(_ctx, getState());
  enterRule(_localctx, 236, Python3Parser::RuleStrings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1430); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1429);
      match(Python3Parser::STRING);
      setState(1432); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == Python3Parser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool Python3Parser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 60: return literal_patternSempred(antlrcpp::downCast<Literal_patternContext *>(context), predicateIndex);
    case 61: return literal_exprSempred(antlrcpp::downCast<Literal_exprContext *>(context), predicateIndex);
    case 68: return pattern_capture_targetSempred(antlrcpp::downCast<Pattern_capture_targetContext *>(context), predicateIndex);
    case 70: return value_patternSempred(antlrcpp::downCast<Value_patternContext *>(context), predicateIndex);
    case 97: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool Python3Parser::literal_patternSempred(Literal_patternContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return  this->CannotBePlusMinus() ;

  default:
    break;
  }
  return true;
}

bool Python3Parser::literal_exprSempred(Literal_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return  this->CannotBePlusMinus() ;

  default:
    break;
  }
  return true;
}

bool Python3Parser::pattern_capture_targetSempred(Pattern_capture_targetContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return  this->CannotBeDotLpEq() ;

  default:
    break;
  }
  return true;
}

bool Python3Parser::value_patternSempred(Value_patternContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return  this->CannotBeDotLpEq() ;

  default:
    break;
  }
  return true;
}

bool Python3Parser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 8);
    case 5: return precpred(_ctx, 6);
    case 6: return precpred(_ctx, 5);
    case 7: return precpred(_ctx, 4);
    case 8: return precpred(_ctx, 3);
    case 9: return precpred(_ctx, 2);
    case 10: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void Python3Parser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  python3parserParserInitialize();
#else
  ::antlr4::internal::call_once(python3parserParserOnceFlag, python3parserParserInitialize);
#endif
}
